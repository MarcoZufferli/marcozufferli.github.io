<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Marco Zufferli</title><link>https://marcozufferli.github.io/posts/</link><description>Recent content in Posts on Marco Zufferli</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener"&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Thu, 11 Sep 2025 17:20:24 +0200</lastBuildDate><atom:link href="https://marcozufferli.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Not So Brief Overview about Kerberos</title><link>https://marcozufferli.github.io/posts/not_so_brief_overview_about_kerberos/</link><pubDate>Thu, 11 Sep 2025 17:20:24 +0200</pubDate><guid>https://marcozufferli.github.io/posts/not_so_brief_overview_about_kerberos/</guid><description>&lt;img src="https://marcozufferli.github.io/not_so_brief_overview_about_kerberos/immagine.jpg" class="center" style="border-radius: 8px;" /&gt;
&lt;h1 id="kerberos-authentication-protocol"&gt;&lt;strong&gt;Kerberos Authentication Protocol&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;Kerberos is the Windows network authentication protocol present by default in versions after Windows 2000; it replaces the NTLM protocol (specifically, NTLMv2) but it should be noted that it can only operate in Active Directory contexts and NOT in Workgroup.&lt;/p&gt;
&lt;p&gt;In a traditional Active Directory authentication scenario, when a user performs a domain authentication on a WorkStation / Server (Interactive Logon) the Client uses the Kerberos protocol for authentication and if, subsequently, the domain user already logged into the Client needs to authenticate with their domain credentials towards a target network service such as SMB (Network Logon), the Kerberos protocol, having SSO capabilities, is used again by the Client.&lt;/p&gt;</description><content type="html"><![CDATA[
    <img src="/not_so_brief_overview_about_kerberos/immagine.jpg"  class="center"  style="border-radius: 8px;"  />


<h1 id="kerberos-authentication-protocol"><strong>Kerberos Authentication Protocol</strong></h1>
<p>Kerberos is the Windows network authentication protocol present by default in versions after Windows 2000; it replaces the NTLM protocol (specifically, NTLMv2) but it should be noted that it can only operate in Active Directory contexts and NOT in Workgroup.</p>
<p>In a traditional Active Directory authentication scenario, when a user performs a domain authentication on a WorkStation / Server (Interactive Logon) the Client uses the Kerberos protocol for authentication and if, subsequently, the domain user already logged into the Client needs to authenticate with their domain credentials towards a target network service such as SMB (Network Logon), the Kerberos protocol, having SSO capabilities, is used again by the Client.</p>
<p>In a Microsoft Active Directory domain, Kerberos is the primary authentication mechanism, for both Interactive Logon and Network Logon (actually also for other LogonTypes), that said, if for any reason the Kerberos protocol CANNOT operate (as when performing a network authentication specifying an IP as the <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#ntlm-in-active-directory">target and not a hostname in Windows utilities</a>, and in fact this is a method to force NTLMv2 authentication over Kerberos) Windows will use the previously available network authentication protocol, that is (usually) NTLMv2; that said, in this section we will detail the Kerberos protocol in all its phases, starting from a scenario that unfolds with an Interactive Logon up to a possible Network Logon.</p>
<p>Kerberos works over the TCP and UDP protocol in clear-text, in fact there is no possibility to implement encryption of the entire communication channel using OpenSSL, this is because it is the Kerberos protocol itself that is responsible for encryption, consequently the encryption mechanism of the Kerberos protocol consists of sending a series of partially already encrypted packets within an unencrypted connection (communication channel).</p>
<p>Kerberos is an authentication protocol, not an authorization protocol, this means that the Kerberos protocol, through the use of TGT, TGS tickets and other related data, is able both to prove to the remote service that the domain user trying to access is indeed a valid domain user, already authenticated and present in the AD (Network Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#1">link</a>), and to the Client when the user performs a standard login to the machine (Interactive Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#2">link</a>); instead, authorization, so the verification of the permissions in order to access to the target service is the responsibility of the AP, that is the server hosting the service (Network Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#3">link</a>), while to the Client it&rsquo;s the responsibility of the Client itself (Interactive Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#4">link</a>).</p>
<p>Kerberos implements the concept of &ldquo;Ticket&rdquo;, that&rsquo;s are &ldquo;objects&rdquo; that will be used to perform domain authentications.
This protocol is called Kerberos, like the three-headed dog of Greek mythology, because in its complete operation (for example from Interactive Logon to Network Logon) it involves 3 distinct actors:</p>
<ul>
<li>
<p><strong>Client / User</strong>: The Client (it&rsquo;s also possible to say the user who has logged into the Client) wants to access a service that requires domain authentication.</p>
</li>
<li>
<p><strong>Application Server (AP)</strong>: The service that the client (or user) wants to access.</p>
</li>
<li>
<p><strong>Key Distribution Center (KDC)</strong>: The Kerberos protocol, to operate, requires the involvement of a Third Party called the Key Distribution Center, which is a functionality of the DC and will be the true core of the protocol and the responsible entity (through its features) for issuing the different Tickets.</p>
<p><span id="7">Specifically, the KDC supports a functionality called Authentication Server (AS), this feature is the one that will actually issue the Tickets called TGT, in some guides it is also said that the KDC has another functionality called Ticket-Granting Server which will be responsible for issuing the other type of Ticket, that is the TGS, that said, for simplicity in this section, instead of specifying the Ticket-Granting Server we will say that it is the KDC itself that issues the TGS.</p>
</li>
</ul>
<p>The Active Directory of a Domain Controller will act as the KDC and the listening ports that expose the service (and therefore the functionalities) of Kerberos will be 88 TCP and 88 UDP.</p>
<p><strong>Kerberos Flow:</strong></p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_flow.png"  class="center"  style="border-radius: 8px;"  />


<blockquote>
<p>In the following sections we&rsquo;ll describe the traditional process where Kerberos is used, so from an Interactive Logon where a user enters their credentials within a WinLOGON GUI, to a subsequent Network Logon (using the credentials cached) to authenticate to a target service; in reality, the Kerberos authentication process can actually also begin using other <a href="https://www.alteredsecurity.com/post/fantastic-windows-logon-types-and-where-to-find-credentials-in-them">Logon Type</a> besides the traditional WinLOGON GUI (Interactive Logon), for example: performing a Kerberos authentication to a service (for instance the SMB service using the PsExec utility from Sysinternals) specifying domain credentials that are different from the ones currently in use; since the Client does NOT have the TGT Ticket of the requested credentials cached (because it logged into the Client with another account) a full Kerberos authentication will be performed.</p></blockquote>
<h2 id="kerberos-flow---interactive-login"><strong>Kerberos Flow - Interactive Login</strong></h2>
<ol>
<li>
<h3 id="krb_"><strong>KRB_AS_REQ: Request of the TGT Token from the Authentication Server (AS)</strong></h3>
<p>The Kerberos protocol is (typically) initialized when a user needs to perform an <a href="https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/windows-logon-scenarios#BKMK_InteractiveLogon">Interactive Logon</a> (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#interactive-logon">1</a>) within a Client using domain credentials, that is by filling in the traditional Windows credential form, also called WinLogon GUI.</p>

        <img src="/not_so_brief_overview_about_kerberos/interactive_logon.png"  class="center"  style="border-radius: 8px;"  />
    

<p>To authenticate, the user enters the credentials on the Client (DOMAIN\User &amp; Password) and everywhing will be shared in cleartext with the &ldquo;LSASS&rdquo; process.</p>
<p><span id="6">After that, LSASS delegates the authentication to its SSPs, so some DLLs (APIs) that can be loaded within the &ldquo;lsass.exe&rdquo; process, consequently the LSASS process loads and shares in cleartext the credentials with all the SSPs dedicated to authentication (kerberos.dll - manage Kerberos, msv1_0.dll - manage NTLM Authentication, wdigest.dll - manage Digest); that said, since the LSASS process does NOT know which SSP to use, <a href="https://syfuhs.net/what-happens-when-you-type-your-password-into-windows">it will use them one by one in sequential order until a correct authentication takes place</a>, consequently, since Windows will recognize that it is a domain user entered, it will start with the &ldquo;kerberos.dll&rdquo; DLL, it then calculates the NT hash of the corresponding previously entered password (which it received in plaintext) and after that contacts the AS (Authentication Service which is a feature of the KDC, that is the DC) to request the issuance of a Ticket called &ldquo;TGT&rdquo; and a &ldquo;TGS Session Key&rdquo;, specifically the LSASS process sends a KRB_AS_REQ which contains:</p>

        <img src="/not_so_brief_overview_about_kerberos/krb_as_req.png"  class="center"  style="border-radius: 8px;"  />
    

<ul>
<li>
<p><strong>Authenticator</strong>: the timestamp contained within it will be encrypted with the userâ€™s hash, while other values such as the â€˜usernameâ€™ field, which contains the name of the domain user we are logging in with, will all be in plain-text.</p>
</li>
<li>
<p><span id="5"><strong>SPN - krbtgt</strong>: It will be indicated in the dedicated field, the SPN related to the Kerberos service (KDC) of the Domain Controller which is equal to krbtgt/[&lt;domain&gt;].</p>
<p>A Service Principal Name (SPN), <a href="/posts/not_so_brief_overview_about_kerberos/#service-principal-name-spn">as we explain later</a> is a unique identifier for the instance of a service, SPNs are used by Kerberos authentication to associate the instance of a service (simplifying: the start &amp; running of the service such as for example Microsoft SQL) with a so-called &ldquo;Logon Account&rdquo;, so a domain user (which in this way it will becomes a Service Account); in other terms, (generically speaking) an SPN can be considered as a generic object that represents the association between a service and a domain user, that said, technically, <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">it is an attribute of the &ldquo;Users&rdquo; object</a> and in fact from it one can list the related SPNs; this essentially means that through an SPN it is possible to map the start &amp; the running of a service present on a server with a domain user rather than associating it with a &ldquo;Standard Service Account&rdquo; such as <a href="https://learn.microsoft.com/it-it/windows/win32/services/networkservice-account?redirectedfrom=MSDN">NetworkService Account</a>; finally, it should be noted that also Computer Accounts have SPNs.</p>
</li>
</ul>
<blockquote>
<p><strong>Note 1</strong>: If the DC is not accessible when a Client performs a domain authentication, the Client checks whether such credentials are present within the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/user-profiles-and-logon/cached-domain-logon-information">Domain Credential Cached (DCC)</a> which stores the last domain users logged into the machine (only if a user authenticates correctly and has the permissions to access the Client), if they are also NOT present there then the login is rejected.</p></blockquote>
<blockquote>
<p><strong>Note 2</strong>: As we will see later, if a domain user has the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties">DONT_REQ_PREAUTH</a> flag enabled, the AS will respond with a valid KRB_AS_REP (response) even if the KRB_AS_REQ (request) packet does not have the &ldquo;Timestamp&rdquo; encrypted with the NTHash of the userâ€™s password.</p></blockquote>
<blockquote>
<p><span id=32> <strong>Note 3</strong>: For simplicity of explanation everything has been described in this way, in reality, what will happen in reality is that the Client will first send a &ldquo;KRB_AS_REQ&rdquo; packet to the AS NOT encrypting the Timestamp with the NT Hash of the current user and only when the AS responds with an error &ldquo;KDC_ERR_PREAUTH_REQUIRED&rdquo; then the Client will send a new &ldquo;KRB_AS_REQ&rdquo; with the Timestamp encrypted, this is the reason why by analyzing everything with Wireshark in a traditional Kerberos authentication one can notice such error message.</p></blockquote>
</li>
<li>
<h3 id="krb_-1"><strong>KRB_AS_REP: AS sends the TGT token to the Client</strong></h3>
</li>
</ol>
<span id="9">
The AS (a feature of the KDC) after having received such request, using the username (which is not encrypted) as a keyword searches inside its Database for the password of that user in order to decrypt the message; if the AS correctly decrypts the message and the now decrypted timestamp falls within the time difference configured in the KDC, then the authentication has occurred successfully.
<blockquote>
<p>If the domain user contained in the first KRB_AS_REQ interaction has the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties">DONT_REQ_PREAUTH</a> property flag enabled, the AS will accept such authentication request as valid EVEN if the request does NOT have the &ldquo;timestamp&rdquo; value encrypted with the NT Hash of the domain user, in such case the AS will simply verify directly whether the timestamp falls within the time difference configured in the KDC; it is important to underline that if the domain user has such flag enabled, the AS will nevertheless respond with a valid KRB_AS_REP both if the KRB_AS_REQ packet has the &ldquo;timestamp&rdquo; encrypted (usually sent by the LSASS process in an Interactive Logon) and if it does NOT have the timestamp encrypted (usually sent by an attacker if performing an AS-REP Roasting Attack).</p></blockquote>
<p>If everything goes well, the AS responds to the client with a packet called KRB_AS_REP containing the TGT Ticket and the TGS Session Key (called &ldquo;Session Key&rdquo; within the screenshot), such TGS Session Key will be used subsequently as an encryption key for the possible following requests.</p>
<p>The KRB_AS_REP packet sent by the AS to the Client contains:</p>
<p><span id="12">
    <img src="/not_so_brief_overview_about_kerberos/krb_as_rep.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li>
<p><strong>Ticket TGT</strong>: The TGT Ticket which has been encrypted with the &ldquo;krbtgt hash&rdquo;, that is the hash (NT Hash) of the domain user called &ldquo;krbtgt&rdquo; (<a href="/posts/not_so_brief_overview_about_kerberos/#5">as previously specified</a>)
<span id="8">Since the Client for obvious reasons does not know the password hash of the KDC it cannot decrypt the TGT Ticket, this is not a problem because to obtain the TGS Ticket in the next step it is sufficient to send the TGT ticket as we received it, that is, encrypted.</p>
</li>
<li>
<p><strong>Other Data</strong>: Other various data, including the TGS Session Key, are encrypted with the hash (NT Hash) of the Client user who requested the domain authentication via Interactive Logon, in this way the KRB_AS_REP packet when sent by the AS to the Client, even if intercepted via Man-In-The-Middle, the attacker could not (hopefully ðŸ˜‰) decrypt the packet since they do not know the hash of the Client user.</p>
</li>
</ul>
<blockquote>
<p>The AS will respond to the Client by sending a KRB_AS_REP with the TGS Session Key (plus other data) encrypted with the NTHash of the domain user regardless of whether it has the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties">DONT_REQ_PREAUTH</a> flag enabled or not, such behavior will lead to an AS-REP Roasting type attack.</p></blockquote>
<hr>
<p><strong>So, what happens now?</strong>
Below are the sequential steps that occur until the userâ€™s home screen is loaded:</p>
<ul>
<li><span id="2"><strong>Authentication</strong>: The Client has now obtained the KRB_AS_REP packet, consequently the LSASS process (or rather its SSP that established the connection, namely &ldquo;Kerberos.dll&rdquo;) performs the decryption of the portion of the KRB_AS_REP packet encrypted with the NT Hash of the domain account performing the authentication (this is because the Client intrinsically knows this value); if this activity is done correctly it means that the authentication has succeeded and for this reason the Kerberos AUTHENTICATION process ends.</li>
</ul>
<blockquote>
<p>It should be noted that the Client stores in memory the TGT Ticket received, this is the reason why if an attacker compromises this machine, they are able to perform a Pass-The-Ticket (PtT).</p></blockquote>
<ul>
<li>
<p><span id="4"><strong>Authorization</strong>: The Client now needs to understand if the domain account authenticated via Kerberos has the authorizations to access, <a href="https://syfuhs.net/what-happens-when-you-type-your-password-into-windows">in order to do this</a>, it should retrieve the information of the authenticated account by inspecting the &ldquo;PAC&rdquo; contained in the received TGT Ticket, but, unfortunately, the PAC contained within the received TGT Ticket is inaccessible since the TGT Ticket is encrypted with the &ldquo;krbtgt&rdquo; hash, consequently, similarly to what happens in a Network Logon scenario (<a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---network-logon">as we will see later</a>), also in this Interactive Logon case, the Client will request a TGS Ticket BUT indicating in the dedicated field an <a href="https://en.hackndo.com/service-principal-name-spn/#edge-case---host">SPN of type &ldquo;HOST&rdquo;</a> related to the Client machine (ex: HOST\Workstation01&quot;) involved, since (1) the service account associated with the Client (ex: Workstation01) is its corresponding <a href="/posts/not_so_brief_overview_about_kerberos/#relationship-between-a-spn--computer-account">&ldquo;Computer Account&rdquo;</a> (ex: DOMAIN\Workstation01$), it will be possible to decrypt the TGS Ticket, extract the PAC and perform the authorization verification:</p>
<ol>
<li><strong>First Authorization Phase</strong>:The SSP &ldquo;kerberos.dll&rdquo; (so the Client) will send a KRB_TGS_REQ packet to the DC in order to request a TGS Ticket; instead of indicating an SPN of a target service (<a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---network-logon">as we will show later in the context of Network Logon</a>) it will indicate the &ldquo;HOST&rdquo; SPN related to the Client machine itself, so where the authentication has just taken place (ex: &ldquo;HOST\Workstation01&rdquo;); in this way the DC will respond with a KRB_TGS_REP containing a TGS Ticket encrypted with the Clientâ€™s domain account &ldquo;Computer Account&rdquo; (ex: DOMAIN\Workstation01$), since the LSASS process of the Client has in memory (specifically in the <a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/lsa-logon-session">LOGON SESSION</a>) the NT Hash of every Security Principal (every authenticated account) of the machine, including also its own <a href="/posts/not_so_brief_overview_about_kerberos/#relationship-between-a-spn--computer-account">&ldquo;Computer Account&rdquo;</a> (ex: DOMAIN\Workstation01$), it will use the NT Hash of such domain account to decrypt the TGS Ticket and then extract in plaintext the PAC contained within it (the PAC is simply &ldquo;signed&rdquo; by the DC with the &ldquo;krbtgt hash&rdquo;, not encrypted) with which it will perform the analysis related to authorizations.</li>
</ol>
<blockquote>
<p>The reason why this step is NOT usually described in a Kerberos authentication articles, is that the Kerberos authentication flow is often captured (from a Windows machine) by <a href="/posts/not_so_brief_overview_about_kerberos/#35">sniffing the network traffic with Wireshark after performing a &ldquo;klist purge&rdquo;</a> (by removing the TGT Ticket, the Client during a Kerberos authentication will necessarily have to re-perform a complete Kerberos authentication); with this procedure, this specific step will NOT be executed because the domain account since is already authenticated on the Client, the Client will NOT need to perform again the AUTHORIZATION check and for this reason it will NOT send this packet during the sniffing.</p></blockquote>
<ol start="2">
<li><strong>Second Authorization Phase</strong>: Another component of the LSASS process will compare the content of the PAC (SID, Group &amp; etc. related to the domain account logged on to the Client) just extracted against the Clientâ€™s ACLs and, if positive, the AUTHORIZATION phase performed by the Client will end.</li>
</ol>
</li>
</ul>
<p><strong>If positive</strong>:</p>
<ol>
<li>
<p>The SSP &ldquo;Kerberos.dll&rdquo; (so the LSASS process) creates a LogonSession (<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/lsa-logon-sessions">it is a data structure present in LSASS</a>) which will represent the domain account just authenticated (ex: ASTRO\Cosmo)</p>
</li>
<li>
<p>Targetting the LogonSession of the user (e.g, ASTRO\Cosmo) just created, Windows (this action is not performed by Kerberos.dll) will associate to it all the previously loaded SSPs (even if only &ldquo;kerberos.dll&rdquo; was actively used for the authentication phase in this context), these SSPs, <a href="/posts/not_so_brief_overview_about_kerberos/#6">as already mentioned</a>, will contain the authenticated userâ€™s credentials in plaintext; this happens to ensure Network Logon SSO functionality (Kerberos or NTLM) since these network protocol requires the use of the current accountâ€™s NT Hash (which is derivable from the plaintext password).</p>
<p>This means that if an attacker is able to dump this Logon Session, they will see all the associated SSPs along with their stored credentials in plaintext (generally speaking since exist some feature that mitigate this logic); that said in reality the MSV SSP (1, 2) will instead provide the NT Hash of the password (dumpable with <a href="https://adsecurity.org/?page_id=1821">sekurlsa::logonpasswords</a>)</p>
</li>
<li>
<p><span id="10">The SSP &ldquo;Kerberos.dll&rdquo; (so the LSASS process) caches the TGT Ticket + TGS Session key inside the Logon Session of the authenticated account (ex: ASTRO\Cosmo) (dumpable with <a href="https://adsecurity.org/?page_id=1821">sekurlsa::tickets</a>)</p>
</li>
<li>
<p>The SSP &ldquo;Kerberos.dll&rdquo; (so the LSASS process) caches a hashed version (MSCACHEV2/MSCASH hashes) of the password of the authenticated account (ex: ASTRO\Cosmo) inside the Domain Credential Cached (DCC) (dumpable <a href="https://adsecurity.org/?page_id=1821">lsadump::cache</a>)</p>
</li>
</ol>
<blockquote>
<p>Since Logon Sessions are created and destroyed dynamically based on user logins and logoffs, an attacker could obtain the NT Hash of a user account (local or domain) only if it is currently logged on (or recently logged on) by dumping the corresponding Logon Session (sekurlsa::logonpasswords) (because the Logon Session still exists inside the memory); the same principle applies also to all the others secrets stored in the Logon Session like for example dumping the Kerberos tickets (sekurlsa::tickets).</p></blockquote>
<ol start="5">
<li>The domain user (e.g ASTRO\Cosmo) <strong>finally</strong> loads the home screen
Since the TGT Ticket and the TGS Session Key have been cached, if a Network Logon attempt occurs Kerberos will be used again.
If a domain user already logged on to the Client (using Kerberos) needs to authenticate to a target network service and thus perform a &ldquo;Network Logon&rdquo; type login, since the Kerberos protocol is SSO (Single Sign On), the following steps are followed.</li>
</ol>
<hr>
<h2 id="kerberos-flow---network-logon"><strong>Kerberos Flow - Network Logon</strong></h2>
<ol start="3">
<li>
<h3 id="krb_-2"><strong>KRB_TGS_REQ: The Client provides the KDC with its TGT Ticket to request the TGS Ticket</strong></h3>
</li>
</ol>
<p>Now that a domain user has already authenticated to a Client (using Kerberos) and already possesses the TGT Ticket with a TGS Session Key, if they need to perform a &ldquo;Network Logon&rdquo; type login, the Kerberos protocol comes into play again, specifically the Client will use the TGT ticket and the TGS Session Key to request another type of ticket called the TGS Ticket.</p>
<blockquote>
<p>The TGS Ticket has been called this way in many publications because it is issued by the Ticket-Granting Services feature (of the DC) which has the acronym TGS, which, <a href="/posts/not_so_brief_overview_about_kerberos/#7">as already mentioned</a>, for simplicity of explanation in these diagrams instead of specifying that the TGS is issued by the Ticket-Granting Services, it was simply said to be issued by the KDC; that said, in the relevant <a href="https://datatracker.ietf.org/doc/html/rfc4120/">RFC4120</a> it is understood that the real name of the TGS Ticket is Service Ticket (ST), this is the reason why in other publications (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#st">1</a>, <a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">2</a>) this type of Ticket is referred to by this other name.</p></blockquote>
<p>The Client presents to the KDC (no longer to the AS functionality) a KRB_TGS_REQ which essentially contains:</p>
<p><span id=13>
    <img src="/not_so_brief_overview_about_kerberos/krb_tgs_req.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li>
<p><strong>Ticket TGT</strong>: The <a href="/posts/not_so_brief_overview_about_kerberos/#8">previously received</a> TGT ticket.</p>
<blockquote>
<p>It has never been decrypted, is sent to the client encrypted as obtained previously, that is, encrypted with the &ldquo;krbtgt hash&rdquo;.</p></blockquote>
</li>
<li>
<p><strong>Authenticator</strong>: Username (domain user who made the request) &amp; Timestamp, both encrypted with the TGS Session Key (obtained with KRB_AS_REP <a href="/posts/not_so_brief_overview_about_kerberos/#10">which was decrypted and cached previously during the Interactive Logon operation</a>.</p>
</li>
<li>
<p><span id=16> <strong>SPN</strong>: The SPN related to / pointing to the service the Client needs to connect to via SSO is sent in plain-text, such as the SPN &ldquo;HTTP/Charlotte.medin.local&rdquo; or &ldquo;CIFS/SERV01&rdquo; (1); in the first, one wants to authenticate to the HTTP service present on the Hostname &ldquo;Charlotte.medin.local&rdquo; while in the second to the CIFS service present on the Hostname SERV01.</p>
</li>
</ul>
<p><span id=18>I want to highlight that both TGT Ticket &amp; TGS Ticket (also called Service Ticket / ST ) both contain the <a href="/posts/not_so_brief_overview_about_kerberos/#privilege-attribute-certificate-pac">Privilege Attribute Certificate (PAC)</a>, that is, a data structure used by the Kerberos protocol to share with the other actors involved in the authentication the security information related to the domain user attempting the login, including: Username, ID, Group Membership and in general all security information; <a href="/posts/not_so_brief_overview_about_kerberos/#11">the PAC is NOT encrypted but ONLY signed</a>.</p>
<ol start="4">
<li>
<h3 id="krb_-3"><strong>KRB_TGS_REP: KDC sends the TGS Ticket to the client</strong></h3>
</li>
</ol>
<p>The KDC, after having received the packet from the Client, being in possession of the &ldquo;krbtgt hash&rdquo; decrypts the received TGT Ticket and extracts the TGT Owner (<a href="/posts/not_so_brief_overview_about_kerberos/#12">&ldquo;username&rdquo; field of the TGT</a>) &amp; the related <a href="/posts/not_so_brief_overview_about_kerberos/#12">TGS Session Key</a>, then it uses such extracted TGS Session Key to decrypt the Authenticator received in that packet (<a href="/posts/not_so_brief_overview_about_kerberos/#13">KRB_TGS_REQ</a>), if everything goes well and the &ldquo;Username&rdquo; field (contained in <a href="/posts/not_so_brief_overview_about_kerberos/#13">KRB_TGS_REQ</a>) matches the TGT Owner (<a href="/posts/not_so_brief_overview_about_kerberos/#12">&ldquo;username&rdquo; field of the TGT Ticket</a>) and the timestamp is valid, then the KDC verifies whether the PAC contained in the received TGT Ticket is valid (the KDC, having the krbtgt hash, computes a signature on the content of the PAC to verify if such output <a href="/posts/not_so_brief_overview_about_kerberos/#15">matches the signature present in the PAC of the TGT Ticket</a>) and if positive generates the TGS Ticket (Service Ticket / ST); in this way the KDC (DC) has ensured that whoever has made the request for a TGS Ticket has a TGT Ticket with a valid related TGS Session Key and that the PAC is correct.</p>
<p>Once the verification is completed, the KDC sends to the Client the KRB_TGS_REP packet containing:</p>
<p><span id=19>
    <img src="/not_so_brief_overview_about_kerberos/krb_tgs_rep.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li><span id=29><strong>Ticket TGS</strong>: TGS Ticket encrypted with the hash of the service account related to the service that the client wishes to access (called in the image &ldquo;Service Owner Hash&rdquo;), it has been retrieved <a href="/posts/not_so_brief_overview_about_kerberos/#16">using the SPN field configured in the KRB_TGS_REQ packet</a>; for example, if via Kerberos SSO (<a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">Page 15</a>) we requested the SPN &ldquo;HTTP/Charlotte.medin.local&rdquo;, the password of the service account associated with that HTTP service (e.g., DOMAIN\websvc) will be used to encrypt the TGS Ticket, if instead the request was made to the SPN &ldquo;MSSQL/db01.medin.local&rdquo;, the password of the service account associated with that MSSQL service (e.g., DOMAIN\sqlengine) will be used to encrypt the TGS Ticket; another scenario is if the request is made, for example, to the SPN &ldquo;CIFS/serv01&rdquo; (one of the several services usually run with the &ldquo;<a href="https://learn.microsoft.com/it-it/windows/win32/services/localservice-account?redirectedfrom=MSDN">Local Service Account</a>&rdquo; - so a <a href="https://learn.microsoft.com/en-us/windows/security/identity-protection/access-control/local-accounts#default-local-system-accounts">Default Local System Account</a>), in this case as well the password of the related Service Account (<a href="/posts/not_so_brief_overview_about_kerberos/#17">so the Computer Account &ldquo;serv01$&rdquo;</a>) will be used to encrypt the TGS Ticket.</li>
</ul>
<blockquote>
<p>The KDC, being the DC, knows the hashes of all domain users, so also the service accounts (which are domain users) and also the hash of the service account that runs the service requested by the Client.</p></blockquote>
<blockquote>
<p>The PAC of the TGS Ticket is a copy of the PAC contained in the <a href="/posts/not_so_brief_overview_about_kerberos/#12">received TGT Ticket</a>.</p></blockquote>
<ul>
<li><strong>Other Data</strong>: A &ldquo;Service Session Key&rdquo;, together with other data, encrypted with the TGS Session Key; it will be used as the encryption key for the final packet exchanges.
As <a href="/posts/not_so_brief_overview_about_kerberos/#18">already mentioned</a>, the TGS Ticket (also called Service Ticket), like the TGT Ticket, contains the PAC (Privilege Attribute Certificate), that is, a structure contained in every ticket which holds the characteristics of the user (SID, group, etc.); furthermore, it must be specified that the PAC is NOT encrypted but signed.</li>
</ul>
<ol start="5">
<li>
<h3 id="krb_-4"><strong>KRB_AP_REQ: The Client attempts to access the AP resource by providing its TGS Ticket</strong></h3>
</li>
</ol>
<p><span id=23>The Client decrypts the portion of the <a href="/posts/not_so_brief_overview_about_kerberos/#19">KRB_TGS_REP</a> packet received using the TGS Session Key that the Client had previously received with the <a href="/posts/not_so_brief_overview_about_kerberos/#9">KRB_AS_REP packet</a> and <a href="/posts/not_so_brief_overview_about_kerberos/#10">cached during the Interactive Login phase</a>, by decrypting it obtains the plaintext value of the &ldquo;Service Session Key&rdquo;, which will be used as the key for this exchange between the Client and the AP.</p>
<p>If everything has gone well, the user now has a valid TGS Ticket to use in order to access the target service, once the verification is completed, the actions are:</p>
<p><span id=26>
    <img src="/not_so_brief_overview_about_kerberos/krb_ap_req.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li>
<p><strong>Ticket TGS</strong>: The Client sends a packet containing the TGS Ticket (Service Ticket / TS) (which had already previously been encrypted with the hash of the service account of the target service) to the AP.</p>
</li>
<li>
<p><strong>Authenticator</strong>: The packet contains an &ldquo;Authenticator&rdquo; (Username + Timestamp) encrypted with the <a href="/posts/not_so_brief_overview_about_kerberos/#23">Service Session Key, so with the key just extracted</a>.
For synthesis reasons it was <strong>NOT</strong> reported in the image but in reality in the KRB_AP_REQ packet the &ldquo;SPN&rdquo; field is sent again, in this way <a href="/posts/not_so_brief_overview_about_kerberos/#1">subsequently</a> the AP will know which service account hash to retrieve in order to decrypt the TGS Ticket to perform the verification.</p>
</li>
</ul>
<hr>
<p><strong>So, again, what happens now?</strong></p>
<p>The AP, after having received the KRB_AP_REQ packet from the Client, performs the following actions:</p>
<ul>
<li>
<p><span id="1"><strong>Authentication</strong>: The AP, having at its disposal the NT Hash of the service account the Client wishes to authenticate to, uses it to decrypt the received TGS Ticket and extracts the PAC &amp; the TGS Owner (&quot;<a href="/posts/not_so_brief_overview_about_kerberos/#19">username field&quot; of the TGS</a>) &amp; the &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#19">Service Session Key</a>&rdquo;. The AP uses this &ldquo;Service Session Key&rdquo; just extracted to decrypt the Authenticator received in the <a href="/posts/not_so_brief_overview_about_kerberos/#26">KRB_AP_REQ</a> packet, if everything goes well and the &ldquo;Username&rdquo; field of the Authenticator (<a href="/posts/not_so_brief_overview_about_kerberos/#26">contained in KRB_AP_REQ</a>) matches the TGS Owner (&quot;<a href="/posts/not_so_brief_overview_about_kerberos/#19">username field&quot; of the TGS</a>) and the timestamp is valid, the &ldquo;AUTHENTICATION&rdquo; phase of the Kerberos protocol is completed.</p>
<blockquote>
<p>It should be noted that the AP stores the received TGS Ticket in memory, this is the reason why if an attacker compromises that machine, they are able to perform a Pass-The-Ticket (PtT).</p></blockquote>
</li>
<li>
<p><span id="3"><strong>Authorization</strong>: The AP uses the PAC <a href="/posts/not_so_brief_overview_about_kerberos/#1">just extracted</a> from the TGS Ticket (Service Ticket / ST) and uses it to determine whether the domain user in question actually has the permissions to access the service, specifically, since the PAC contains in plain-text (<a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">page 13</a>) (the PAC is simply &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#11">signed</a>&rdquo; by the DC with the &ldquo;krbtgt hash&rdquo;, not encrypted) the security information of the domain user who needs to connect to the service, such as SID, Username, RID and other data, the AP compares this information with the ACLs related to the service, if the outcome is positive the AP will grant the Client access to the service and this <strong>finaly</strong> concludes the &ldquo;AUTHORIZATION&rdquo; phase which I highlight is carried by the AP, so by the service.</p>
</li>
</ul>
<p>As can be seen, the Kerberos protocol validates to the target service (e.g. CIFS/SMBSERVER01) that the domain user who requested access is authenticated and valid (<a href="/posts/not_so_brief_overview_about_kerberos/#1">AUTHENTICATION</a>), while it&rsquo;s the target service itself (e.g. CIFS/SMBSERVER01), or rather the server hosting that service, namely the AP, that is responsible for verifying whether that user has the necessary permissions to access that service (<a href="/posts/not_so_brief_overview_about_kerberos/#3">AUTHORIZATION</a>).</p>
<p>Due to how the Kerberos protocol works, the AP (the server hosting the service such as CIFS to which the domain user needs to authenticate) will NEVER receive the NT Hash of the domain user who authenticated, because the AP will only receive the KRB_AP_REQ packet which does not contain such data, this means that if an attacker exploits the AP, from it they will not be able to recover the domain credentials of the users who have connected via SSO to that service.</p>
<hr>
<p><span id=33><strong>Optional</strong></p>
<p>Although it is not the Kerberos protocol itself but the <a href="https://www.tarlogic.com/blog/how-kerberos-works/">NRPC (NetLogon) protocol</a> (<a href="https://adsecurity.org/?p=1515">1</a>), if the AP needs to verify whether the PAC received (<a href="/posts/not_so_brief_overview_about_kerberos/#26">contained in the TGS Ticket</a>) is valid, <a href="/posts/not_so_brief_overview_about_kerberos/#28">a checks that it does not happen often</a>, it can verify it by sending a packet named <a href="https://learn.microsoft.com/en-us/archive/blogs/openspecification/understanding-microsoft-kerberos-pac-validation#kerberos-pac-validation">KERB_VERIFY_PAC_REQUEST</a> as indicated later; furthermore, if the Client explicitly requests it (<a href="https://datatracker.ietf.org/doc/html/rfc1510#section-5.5.1">flag &ldquo;ap-options=1&rdquo;</a> inside the <a href="/posts/not_so_brief_overview_about_kerberos/#26">KRB_AP_REQ packet</a>), the AP must also authenticate itself to the Client, this concent is called &ldquo;Mutual Authentication&rdquo;; if both activities are required, the following steps 6, 7, and 8 will take place, and only after their completion the AP (or rather its service) will grant access to the Client.</p>
<blockquote>
<p><span id=28>I want to highlight that the PAC contained in the TGT Ticket is ALWAYS validated (when the DC receives the KRB_TGS_REQ) while the PAC contained in the TGS Ticket is validated ONLY if properly configured (by configuring a registry which is disabled by default).
In the case where both the PAC verification and the Client request for Mutual Authentication are present, the following steps occur:</p></blockquote>
<ol start="6">
<li>
<h3 id="optional-kerb_"><strong>(Optional) KERB_VERIFY_PAC_REQUEST</strong></h3>
</li>
</ol>
<p>In the case where the service (AP) wants to validate whether the PAC received (contained in the TGS Ticket) is valid, it uses the Netlogon protocol <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/b27be921-39b3-4dff-af4a-b7b74deb33b5">to ask the DC</a> to verify the PAC signature.</p>
<ol start="7">
<li>
<h3 id="optional-pac_"><strong>(Optional) PAC_RESPONSE</strong></h3>
</li>
</ol>
<p>The DC will verify if the PAC is valid (for simplicity of explanation, we can say that the DC will calculate a &ldquo;signature&rdquo; on the PAC content and if this output matches the existing signature, then the PAC will be considered valid) and will respond with a code indicating if it is correct; this packet representing the response has no specific name, it is simply called &ldquo;<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/b27be921-39b3-4dff-af4a-b7b74deb33b5">PAC RESPONSE</a>&rdquo;.</p>
<ol start="8">
<li>
<h3 id="optional-krb_"><strong>(Optional) KRB_AP_REP</strong></h3>
</li>
</ol>
<p>Finally, optionally, if the Client explicitly requests it, even the service itself (and NOT the related service account), so the AP, must authenticate itself performing a so-called &ldquo;mutual authentication&rdquo;; to do this, instead of contacting the AD, the AP responds directly to the Client by sending a <a href="https://datatracker.ietf.org/doc/html/rfc4120#section-5.5.2">KRB_AP_REP</a> (as a response to the previous KRB_AP_REQ) <a href="https://datatracker.ietf.org/doc/html/rfc4120#section-5.5.2">containing a TIMESTAMP encrypted</a> with the &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#19">Service Session Key</a>&rdquo;; if the Client correctly decrypts the TIMESTAMP with the &ldquo;Service Session Key&rdquo; it possesses (the Client has the legitimate &ldquo;Service Session Key&rdquo; because it received it from the DC in the <a href="/posts/not_so_brief_overview_about_kerberos/#19">KRB_TGS_REP</a>), then it is demonstrated that the AP, having the correct &ldquo;Service Session Key&rdquo;, is legitimate (this is because the AP, to have this legitimate &ldquo;Service Session Key&rdquo;, would have had to extract the data from the TGS received from the Client - KRB_AP_REQ - which was encrypted with the &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#29">Service Owner Hash</a>&rdquo;, information that only the legitimate AP should know); in other words, <a href="https://www.educative.io/blog/kerberos-in-5-minutes">in this way the Client is sure it is connecting to the original service</a> and not to another service of a potential attacker pretending to be the original service.</p>
<h2 id="privilege-attribute-certificate-pac"><strong>Privilege Attribute Certificate (PAC)</strong></h2>
<h3 id="what"><strong>What&rsquo;s a Privilege Attribute Certificate (PAC)?</strong></h3>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#18">As already mentioned</a>, the <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962">Privilege Attribute Certificate (PAC)</a> is a data structure that uses the Kerberos protocol to share with the other actors involved in the authentication, the security information related to the domain account attempting the login, including: Username, ID, Group Membership, and in general all security information.</p>
<p>The PAC is particularly important as it is used during the AUTHORIZATION phase (I want to remind that it is not managed by the Kerberos protocol) respectively either by the Client in an <a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---interactive-login">Interactive Logon</a> or by the AP / Remote Service in a <a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---network-logon">Network Logon to</a> understand if the domain account can access the service or not.</p>
<p>The PAC is contained inside the both types of Kerberos Tickets TGT &amp; TGS (in the &ldquo;authorization-data&rdquo; field), consequently the PAC is indirectly encrypted with the &ldquo;krbtgt&rdquo; account hash in the first case (TGT Ticket) or indirectly encrypted with the service account hash against which the authentication is performed in the second case (TGS Ticket).</p>
<p>Below there is an image that shows the content of a PAC within a TGS Ticket:</p>

    <img src="/not_so_brief_overview_about_kerberos/PAC.png"  class="center"  style="border-radius: 8px;"  />


<p>A traditional account performing Kerberos authentication, NOT knowing the hash to decrypt the TGT Ticket or the hash to decrypt the TGS Ticket, it means that the PAC could not be readable by a traditional user.</p>
<ul>
<li><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3122bf00-ea87-4c3f-92a0-91c0a99f5eec">KDC Signature</a></strong>: &ldquo;KDC Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) created by signing the PAC content with the secret of the &ldquo;krbtgt&rdquo; account (default service account of the KDC).</li>
</ul>
<p><span id=11>Furthemore, i want to highlight that the PAC entity itself is issued by the DC in a &ldquo;signed&rdquo; way (not encrypted), meaning that inside it there will be several fields containing the signatures (checksums) calculated on the PAC content with a specific &ldquo;key&rdquo;; these signatures contained inside the PAC can potentially be used to verify the integrity of the PAC it self, below we see <a href="https://trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you">briefly</a>(<a href="https://www.youtube.com/watch?t=871&amp;v=Jaa2LmZaNeU&amp;feature=youtu.be&amp;themeRefresh=1">1</a>) what types of signatures it possesses:
<strong>Ticket TGS</strong>:</p>
<ul>
<li>
<p><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/a194aa34-81bd-46a0-a931-2e05b87d1098">Server Signature</a></strong>: &ldquo;Server Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) calculated by signing the PAC content with the secrets of the service account against which authentication is attempted.</p>
</li>
<li>
<p><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3122bf00-ea87-4c3f-92a0-91c0a99f5eec">KDC Signature</a></strong>: &ldquo;KDC Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) created by signing the PAC content with the secret of the &ldquo;<a href="https://www.tarlogic.com/cybersecurity-glossary/krbtgt/">krbtgt</a>&rdquo; account (default service account of the KDC).</p>
</li>
</ul>
<blockquote>
<p>This signature is the one that could be checked inside a TGS Ticket to prevent a Silver Ticket BUT as this is <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#pac">NOT</a> done.</p></blockquote>
<p><span id=15> <strong>Ticket TGT</strong>:</p>
<ul>
<li><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3122bf00-ea87-4c3f-92a0-91c0a99f5eec">KDC Signature</a></strong>: &ldquo;KDC Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) created by signing the PAC content with the secret of the &ldquo;<a href="https://www.tarlogic.com/cybersecurity-glossary/krbtgt/">krbtgt</a>&rdquo; account (default service account of the KDC).</li>
</ul>
<p>In reality the TGT Ticket also has a field dedicated to the &ldquo;Server Signature&rdquo; but having no meaning, since it is the TGS Ticket that is used to authenticate to services and not the TGT Ticket, a &ldquo;symbolic&rdquo; value will be present there which will have no relevance.</p>
<h2 id="kerberos-keys"><strong>Kerberos Keys</strong></h2>
<h3 id="what-1"><strong>What&rsquo;s a Kerberos Key?</strong></h3>
<p>As already seen, the Kerberos protocol allows the user to request a TGT Ticket from the Domain Controller by sending a KRB_AS_REQ encrypting the &ldquo;Timestamp&rdquo; field with the NT Hash of the account performing the authentication, if it is correct everything proceeds properly, that said, in reality, the Kerberos protocol also more generically accepts the entity called &ldquo;Kerberos Keys&rdquo;.</p>
<p>When a domain account is created, the Domain Controller will take as input the corresponding plain-text password and encrypt it using different algorithms, the output of these will be the entity called &ldquo;Kerberos Keys&rdquo;:</p>
<ul>
<li>
<p><strong>AES 256 Key</strong>: &ldquo;AES 256 Key&rdquo; is the output of the plain-text password using the &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">AES256_HMAC_SHA1</a>&rdquo; algorithm.</p>
<p>This &ldquo;AES 256 Key&rdquo; is the Kerberos Key most commonly used by the Kerberos protocol, consequently an attacker using this Key instead of others will be able to bypass detection tools more easily.</p>
</li>
<li>
<p><strong>AES 128 Key</strong>: &ldquo;AES 128 Key&rdquo; is the output of the plain-text password using the &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">AES128_HMAC_SHA1</a>&rdquo; algorithm.</p>
</li>
<li>
<p><strong>DES Key (DES_CBC_MD5)</strong>: &ldquo;DES Key&rdquo; is the output of the plain-text password using the &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">DES_CBC_MD5</a>&rdquo; algorithm.</p>
</li>
<li>
<p><strong>RC4 Key</strong>: &ldquo;RC4 Key&rdquo; is the output of the plain-text password using the now deprecated &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">RC4_HMAC_MD5</a>&rdquo; algorithm.</p>
<p>This &ldquo;RC4 Key&rdquo; is nothing more than the NT Hash of the domain account password, consequently, being synonyms, it means that the term &ldquo;NT Hash&rdquo; used during the explanation of the Kerberos protocol is nothing more than the &ldquo;RC4 Key&rdquo;.</p>
</li>
</ul>
<p>An attacker is able to retrieve the Kerberos Keys for example by dumping the &ldquo;<a href="https://www.semperis.com/blog/ntds-dit-extraction-explained/">NTDS.dit</a>&rdquo; file from the Domain Controller, below there is an example using the <a href="https://github.com/fortra/impacket/blob/master/examples/secretsdump.py">Secretsdump</a> utility:</p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_key_1.png"  class="center"  style="border-radius: 8px;"  />


<p>In the section indicated above, the &ldquo;RC4 Keys&rdquo; are NOT present because as the tool for semplicity places them in the section dedicated to the NT Hash of the domain accounts.</p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_key_2.png"  class="center"  style="border-radius: 8px;"  />


<p>If an attacker manages to obtain a Kerberos Key of a victim account, they would be able to impersonate it in a Kerberos authentication using an attack called &ldquo;Pass-The-Key&rdquo;.</p>
<h2 id="service-principal-name-spn"><strong>Service Principal Name (SPN)</strong></h2>
<h3 id="what-2"><strong>What&rsquo;s a Service Principal Name (SPN)?</strong></h3>
<p>A &ldquo;<a href="https://en.wikipedia.org/wiki/Service_account">Service Account</a>&rdquo; is nothing more than an account created and used for the start &amp; running of a specific service, furthermore, if this service needs to interact with other services it can do it using its own &ldquo;Service Account&rdquo;.</p>
<p>In a classic scenario when the local or domain user &ldquo;BOB&rdquo; starts the software &ldquo;Notepad&rdquo; application, the operating system runs &ldquo;Notepad&rdquo; using the account &ldquo;BOB&rdquo;, when a Service Account is used, instead, the OS will start the service (for example MMSQL) using that specific Service Account, this will mean that viewing the running processes though Task Manager it will be possible to see that the service &ldquo;Microsoft SQL&rdquo; is running with the related &ldquo;Service Account&rdquo;.</p>
<p>One type of &ldquo;Service Account&rdquo; are the &ldquo;<a href="https://learn.microsoft.com/en-us/windows/win32/services/service-user-accounts">Standard Service Account</a>&rdquo;, so &ldquo;Service Accounts&rdquo; that do NOT have passwords and they are used by Windows OS to start specific services usually system-related, the most common example is the &ldquo;<a href="https://learn.microsoft.com/it-it/windows/win32/services/networkservice-account?redirectedfrom=MSDN">NetworkService Account</a>&rdquo; which is usually used to start the IIS or MSSQL Server service.</p>
<p><span id=30>A <a href="https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names">Service Principal Name (SPN)</a> is a unique identifier of a service instance, SPNs are used by Kerberos authentication to associate the service instance (the start &amp; running of the service, for example Microsoft SQL) with a &ldquo;Logon Account&rdquo; (which it will become Service Account); in other words, (generically speaking) an SPN can be considered as a generic object that represents the association between a service and a domain account, that said, technically, <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">it is an attribute of the &ldquo;Users&rdquo; object</a>.</p>
<p><span id=31>&ldquo;Standard Service Accounts&rdquo; by definition are NOT &ldquo;Logon Accounts&rdquo; since they are used exclusively by the operating system and do NOT have passwords.</p>
<p>This essentially means that through an SPN it is possible to map the start &amp; running of a service on a server to a domain account rather than associating it with a &ldquo;Standard Service Account&rdquo; such as the NetworkService Account
Each service (hosted on a server joined into a domain) that wants a domain user to authenticate to it using the Kerberos protocol (Kerberos SSO) must necessarily have an SPN configured so that the potential &ldquo;Client&rdquo; (so the actor involved in Kerberos Authentication) can uniquely identify the service within the network; if no SPN is set for a service, then the Client has NO way to locate the service and consequently the Kerberos authentication is NOT possible.</p>
<p>An SPN (so an attribute of the &ldquo;user&rdquo; object) is (usually, it&rsquo;s not mandatorylin) built using the name of the &ldquo;service class&rdquo; followed by the hostname that starts the service; finally, optionally, it can also include the port and an arbitrary name to associate:</p>
<p><span id="target-text2">
    <img src="/not_so_brief_overview_about_kerberos/spn1.png"  class="center"  style="border-radius: 8px;"  />

</p>
<p>For example: A SPN named &ldquo;DNS/dc01.capsule.corp&rdquo; rappresent a DNS Service hosted on the DC01.capsule.corp associated with a domain user like &ldquo;capsule.corp\arbitrary_dnsuser&rdquo;.</p>
<p>Microsoft has documented a (non-exhaustive) list of the so-called &ldquo;service_class,&rdquo; that is, standard names used to indicate certain types of services; as you can see, the most common are <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">CIFS, DNS, SPOOLER and WWW</a>.</p>
<h3 id="relationship-between-a-spn--computer-account"><strong>Relationship Between a SPN &amp; Computer Account</strong></h3>
<p>In a domain scenario, each &ldquo;person&rdquo; within the organization will have its own domain user account (so a &ldquo;Users&rdquo; object); that said, every computer joined to the domain will also have its own associated domain account, called a &ldquo;Computer Account&rdquo; or &ldquo;Machine Account&rdquo; (<a href="https://itfreetraining.com/lesson/computer-accounts/">1</a>, <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts">2</a>) which will be used by the Client itself (or more precisely by the SYSTEM account of the Client) for activities where it needs to interact with other entity joined within the domain, for example checking if it is necessary to update the &ldquo;Group Policies&rdquo; (Client -&gt; Domain Controller), <a href="/posts/not_so_brief_overview_about_kerberos/#4">verifying the permissions of a domain account authenticated to the computer with Kerberos and so on</a>.</p>
<p>The difference between a &ldquo;User&rdquo; and a &ldquo;Computer Account&rdquo; is that even though both are domain user that exists and are registered on the DC, the first is an object of type &ldquo;<a href="https://www.windows-active-directory.com/active-directory-user-objects-management.html">User</a>,&rdquo; while the second, that is, the &ldquo;Computer Account,&rdquo; is instead <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts">a subclass of the &ldquo;User&rdquo; class</a> (so we can say it&rsquo;s a user) BUT it is stored within a &ldquo;Computer&rdquo; object.</p>
<p>The following command queries the DC and requests to print on screen all the domain accounts that exists in the AD; as you can see, in addition to the Administrator account, there are: the nominal account (tstark, fcastle, pparker), the service account (SQLService) and 3 other accounts indicated with a $ at the end of the syntax, those are the &ldquo;Computer Accounts&rdquo;; all &ldquo;Computer Accounts&rdquo; (or &ldquo;Machine Accounts&rdquo;) have as their name the associated hostname and end with the $ sign.</p>

    <img src="/not_so_brief_overview_about_kerberos/spn2.png"  class="center"  style="border-radius: 8px;"  />


<p>Consequently, &ldquo;HYDRA-DC$&rdquo; is the &ldquo;Computer Account&rdquo; of the Domain Controller HYDRA-DC, &ldquo;THEPUNISHER$&rdquo; is the &ldquo;Computer Account&rdquo; of the Client THEPUNISHER, and finally &ldquo;SPIDERMAN$&rdquo; is the &ldquo;Computer Account&rdquo; of the Client SPIDERMAN.</p>
<p><span id=34>A &ldquo;Computer Account&rdquo; (Machine Account), unlike a traditional domain user, is automatically generated by the DC when the computer is joined to the domain; specifically, the computer itself randomly (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#kerberoast">120 characters</a>) creates the password (and then shares it with the DC) and by default it will use the machineâ€™s hostname followed by a $ for the creation of the name; that said, the password of the domain account &ldquo;Computer Account&rdquo; is instead changed <a href="https://adsecurity.org/?p=280">by default</a> (this timing is configurable - <a href="https://techcommunity.microsoft.com/blog/askds/machine-account-password-process/396026">1</a>, <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#lsa-secrets">2</a>) every 30 days.</p>
<p>In addition to the existence of SPNs that allow associating a domain user (becoming a Service Account in this scenario) with a specific service, so by setting a specific &ldquo;Service Class&rdquo; such as CIFS or others, there is also a SPNs of type &ldquo;HOST&rdquo;.</p>
<p>Technically, <a href="/posts/not_so_brief_overview_about_kerberos/#30">as previously told</a>, an SPN was created with the purpose of associating a service with a Service Account (domain user), a SPN of type HOST is the exception to this rule since the keyword &ldquo;HOST&rdquo; is NOT a service but directly represents the whole &ldquo;computer&rdquo; object itself, in order to associate a whole &ldquo;Computer&rdquo; object with a Service Account via SPN, in reality a trick is used, essentially the keyword HOST in order to represent the whole machine but having to necessarily specify a service, the &ldquo;HOST&rdquo; Service Class is an ALIAS (<a href="https://en.hackndo.com/service-principal-name-spn/#edge-case---host">1</a>, <a href="https://learn.microsoft.com/en-us/windows/win32/adschema/a-spnmappings">2</a>) that groups together all the possible <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">Service Class</a> of an SPN such as CIFS, WWW, DNS etc, subsequently it was defined that the Service Account that can be associated with the &ldquo;Computer&rdquo; object (which indirectly holds the Host SPN) via SPN is its corresponding &ldquo;Computer Account&rdquo;, in other words, for example: The SPN &ldquo;HOST\Workstation1&rdquo; links the Computer object &ldquo;Workstation1&rdquo; to the Service Account &ldquo;Workstation1$&rdquo; (which is a Computer Account).</p>
<p><span id=17>Finally, it should be specified that if a service is run on a computer with a &ldquo;Standard Service Account&rdquo; (for example Local System / NetworkService Account), such as by default the CIFS / LDAP services, if these services need to use the Kerberos protocol (for example they accept a Kerberos domain authentication) the computer will use the &ldquo;Computer Account&rdquo; of the machine that host these services as their Service Account (in this scenario the &ldquo;secrets&rdquo; of the Computer Account will be used to encrypt the TGS Ticket); this happens because the &ldquo;Standard Service Account&rdquo; (ex Local System / NetworkService Account) <a href="/posts/not_so_brief_overview_about_kerberos/#31">exists only in a local context</a>.</p>
<h2 id="inspect-the-kerberos-yourself"><strong>Inspect the Kerberos yourself!</strong></h2>
<p>Now that the theory has been explained i recommend moving on to practice!</p>
<p><span id=35>For educational purposes i recommend creating your own personal lab, there are several resources online that detail <a href="https://www.youtube.com/watch?v=xftEuVQ7kY0">how to do this</a>, once this has been done, it will be possible to use WireShark to analyze the traffic started from a Kerberos authentication, to see the whole process we can for example run the command &ldquo;klist purge&rdquo; (which removes all the Cached Kerberos Tickets) on a domain joined Windows machine and perform a Network Logon authentication to another machine within the network, for example via SMB, if you have do this you will see all the Kerberso traffic generated.</p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_wholeflow.png"  class="center"  style="border-radius: 8px;"  />


<p>As you can see with the following traffic has been generated:</p>
<ol>
<li>KRB_AS_REQ</li>
</ol>
<p>The reason why the 2 &ldquo;KRB_AS_REQ&rdquo; packets were sent <a href="/posts/not_so_brief_overview_about_kerberos/#32">has been previously analyzed.</a></p>
<ol start="2">
<li>KRB_AS_REP</li>
<li>KRB_TGS_REQ</li>
<li>KRB_TGS_REP</li>
</ol>
<p>In this scenario, only &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#33">Mutual Authentication</a>&rdquo; is enabled:</p>
<ol start="5">
<li>KRB_AP_REQ: The Kerberos packet &ldquo;KRB_AP_REQ&rdquo; is encapsulated within the packet related to the protocol used by the service hosted by the AP, in this case it&rsquo;s SMB.</li>
</ol>
<ul>
<li>KRB_AP_REP: Since &ldquo;Mutual Authentication&rdquo; is enabled, the AP will respond to the Client with a KRB_AP_REP, always embedding it in this example inside the SMB protocol.</li>
</ul>
<h3 id="how-to-decrypt-kerberos-traffic"><strong>How to decrypt Kerberos traffic</strong></h3>
<p>As previously analyzed, some portions of the Kerberos packets will be encrypted with the krbtgt account secrets (TGT Ticket) or with the Service Account secrets related to the service hosted by the AP (TGS Ticket), to be able to analyze everything in plain-text it&rsquo;s necessary to properly configure Wireshark, specifically it is possible to provide Wireshark with a &ldquo;<a href="https://web.mit.edu/kerberos/krb5-devel/doc/basic/keytab_def.html">keytab</a>&rdquo; file containing ALL the secrets (NT Hash &amp; <a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-keys">Kerberos Key</a>) related to the entities involved in Kerberos authentication, in this way Wireshark will be able to decrypt the part.</p>
<blockquote>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#34">As already explained</a>, since by default the DC changes the password of ALL Computer Accounts every 30 days, if this behavior is not disabled / modified, the operation will need to be repeated periodically.</p></blockquote>
<p>To do this, one can perform a DCSync on the Domain Controller and retrieve the NT Hashes, AES-256 Kerberos Key, and AES-128 Kerberos Key of each involved &ldquo;Principal&rdquo; (Domain Users &amp; Computer Accounts &amp; krbtgt user), then insert these values into the dedicated section in the &ldquo;<a href="https://github.com/dirkjanm/forest-trust-tools/blob/master/keytab.py">keytab.py</a>&rdquo; script and finally execute the script to generate the &ldquo;keytab.kt&rdquo; file:</p>
<ul>
<li>
<p>Dump the &ldquo;secrets&rdquo; (perform a DCSync).</p>

      <img src="/not_so_brief_overview_about_kerberos/dcsync.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
<li>
<p>Populate the &ldquo;<a href="https://github.com/dirkjanm/forest-trust-tools/blob/master/keytab.py">keytab.py</a>&rdquo; script.</p>

      <img src="/not_so_brief_overview_about_kerberos/keytab1.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
<li>
<p>Execute the &ldquo;keytab.py&rdquo; script to generate the &ldquo;keytab.kt&rdquo; file.</p>

      <img src="/not_so_brief_overview_about_kerberos/keytab2.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
</ul>
<p>Once this is done, go to Wireshark and navigate to &ldquo;Edit -&gt; Preferences -&gt; Protocols -&gt; KRB5&rdquo;, select the file and check the box &ldquo;Try to decrypt Kerberos blob&rdquo;.</p>

    <img src="/not_so_brief_overview_about_kerberos/keytab3.png"  class="center"  style="border-radius: 8px;"  />


<p>Once everything is done, all the encrypted Wireshark traffic that has been correctly decrypted will be highlighted in blue, while if the decryption has failed it will be highlighted in yellow:</p>

    <img src="/not_so_brief_overview_about_kerberos/keytab4.png"  class="center"  style="border-radius: 8px;"  />


<h2 id="outro"><strong>Outro</strong></h2>
<p>The Kerberos protocol is a beast to understand and we have only scratched its surface, with this article i hope to have clarified its basic behavior, if you notice any inaccuracies or want to ask me something, do not hesitate to write to me!</p>
<h2 id="references"><strong>References</strong></h2>
<ul>
<li><a href="https://stealthbits.com/blog/what-is-kerberos/">https://stealthbits.com/blog/what-is-kerberos/</a></li>
<li><a href="https://www.tarlogic.com/en/blog/how-kerberos-works/">https://www.tarlogic.com/en/blog/how-kerberos-works/</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-accounts#krbtgt-account">https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-accounts#krbtgt-account</a></li>
<li><a href="https://www.devadmin.it/2020/07/27/account-krbtgt-e-best-practices-di-sicurezza/">https://www.devadmin.it/2020/07/27/account-krbtgt-e-best-practices-di-sicurezza/</a></li>
<li><a href="https://www.educative.io/blog/kerberos-in-5-minutes">https://www.educative.io/blog/kerberos-in-5-minutes</a></li>
<li><a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf</a></li>
<li><a href="https://www.crowdstrike.com/cybersecurity-101/ntlm-windows-new-technology-lan-manager/">https://www.crowdstrike.com/cybersecurity-101/ntlm-windows-new-technology-lan-manager/</a></li>
<li><a href="https://en.hackndo.com/kerberos/">https://en.hackndo.com/kerberos/</a></li>
<li><a href="https://learn.microsoft.com/en-us/archive/blogs/openspecification/">https://learn.microsoft.com/en-us/archive/blogs/openspecification/</a></li>
<li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13</a></li>
<li><a href="https://syfuhs.net/what-happens-when-you-type-your-password-into-windows">https://syfuhs.net/what-happens-when-you-type-your-password-into-windows</a></li>
<li><a href="https://swarm.ptsecurity.com/kerberoasting-without-spns/">https://swarm.ptsecurity.com/kerberoasting-without-spns/</a></li>
<li><a href="https://labs.lares.com/fear-kerberos-pt1/#preauth">https://labs.lares.com/fear-kerberos-pt1/#preauth</a></li>
<li>https//www.chudamax.com/posts/kerberos-102-overview/</li>
<li><a href="https://en.hackndo.com/kerberos-silver-golden-tickets/#pac">https://en.hackndo.com/kerberos-silver-golden-tickets/#pac</a> <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#pac">https://zer1t0.gitlab.io/posts/attacking_ad/#pac</a></li>
<li><a href="https://trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you">https://trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you</a></li>
<li><a href="https://labs.lares.com/author/raul/">https://labs.lares.com/author/raul/</a></li>
<li><a href="https://zer1t0.gitlab.io/posts/attacking_ad/#user-kerberos-keys">https://zer1t0.gitlab.io/posts/attacking_ad/#user-kerberos-keys</a></li>
<li><a href="https://www.thehacker.recipes/ad/movement/kerberos/ptk">https://www.thehacker.recipes/ad/movement/kerberos/ptk</a></li>
<li><a href="https://en.wikipedia.org/wiki/Service_account">https://en.wikipedia.org/wiki/Service_account</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names">https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names</a></li>
<li><a href="https://malicious.link/posts/2016/kerberoast-pt1/">https://malicious.link/posts/2016/kerberoast-pt1/</a></li>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815(v=ws.10)#service-principal-names</a></li>
<li><a href="https://en.hackndo.com/service-principal-name-spn/#edge-case---host">https://en.hackndo.com/service-principal-name-spn/#edge-case---host</a></li>
<li><a href="https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts">https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts</a></li>
</ul>
]]></content></item></channel></rss>