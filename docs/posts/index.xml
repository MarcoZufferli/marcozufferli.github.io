<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Marco Zufferli</title><link>https://marcozufferli.github.io/posts/</link><description>Recent content in Posts on Marco Zufferli</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener"&gt;CC BY-NC 4.0&lt;/a&gt;</copyright><lastBuildDate>Tue, 16 Sep 2025 14:56:19 +0200</lastBuildDate><atom:link href="https://marcozufferli.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Demystify Kerberos Delegation</title><link>https://marcozufferli.github.io/posts/demystify_kerberos_delegation/</link><pubDate>Tue, 16 Sep 2025 14:50:00 +0200</pubDate><guid>https://marcozufferli.github.io/posts/demystify_kerberos_delegation/</guid><description>&lt;hr&gt;
&lt;h4 id="table-of-contents"&gt;Table of Contents:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://marcozufferli.github.io/posts/demystify_kerberos_delegation/#whats-kerberos-delegation"&gt;What&amp;rsquo;s Kerberos Delegation&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://marcozufferli.github.io/posts/demystify_kerberos_delegation/#unconstrained-delegation"&gt;Unconstrained Delegation&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://marcozufferli.github.io/posts/demystify_kerberos_delegation/#constrained-delegation"&gt;Constrained Delegation&lt;/a&gt;&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://marcozufferli.github.io/posts/demystify_kerberos_delegation/#constrained-delegation-kerberos-only"&gt;Constrained Delegation (Kerberos only)&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://marcozufferli.github.io/posts/demystify_kerberos_delegation/#constrained-delegation-use-any-authentication-protocol--protocol-transition"&gt;Constrained Delegation (Use any authentication Protocol) / Protocol Transition&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href="https://marcozufferli.github.io/posts/demystify_kerberos_delegation/#resource-based-constrained-delegation-rbcd"&gt;Resource Based Constrained Delegation (RBCD)&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id="kerberos-delegation"&gt;&lt;strong&gt;Kerberos Delegation&lt;/strong&gt;&lt;/h1&gt;
&lt;img src="https://marcozufferli.github.io/demystify_kerberos_delegation/immagine.jpg" class="center" style="border-radius: 8px;" /&gt;
&lt;h2 id="what"&gt;&lt;strong&gt;What&amp;rsquo;s Kerberos Delegation?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Before you begin, if you are not confident with Kerberos, i highly suggest you to start reading my other article called &amp;ldquo;&lt;a href="https://marcozufferli.github.io/posts/not_so_brief_overview_about_kerberos/"&gt;Not So Brief Overview about Kerberos&lt;/a&gt;&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s assume a scenario where a domain user authenticates via Kerberos to a &amp;ldquo;Front-End&amp;rdquo; AP (service) such as a Web Application, which, to operate correctly, must interact with a &amp;ldquo;Back-End&amp;rdquo; AP (service) such as a Database or a File Server.&lt;/p&gt;</description><content type="html"><![CDATA[<hr>
<h4 id="table-of-contents">Table of Contents:</h4>
<ul>
<li><strong><a href="/posts/demystify_kerberos_delegation/#whats-kerberos-delegation">What&rsquo;s Kerberos Delegation</a></strong></li>
<li><strong><a href="/posts/demystify_kerberos_delegation/#unconstrained-delegation">Unconstrained Delegation</a></strong></li>
<li><strong><a href="/posts/demystify_kerberos_delegation/#constrained-delegation">Constrained Delegation</a></strong>
<ul>
<li><strong><a href="/posts/demystify_kerberos_delegation/#constrained-delegation-kerberos-only">Constrained Delegation (Kerberos only)</a></strong></li>
<li><strong><a href="/posts/demystify_kerberos_delegation/#constrained-delegation-use-any-authentication-protocol--protocol-transition">Constrained Delegation (Use any authentication Protocol) / Protocol Transition</a></strong></li>
</ul>
</li>
<li><strong><a href="/posts/demystify_kerberos_delegation/#resource-based-constrained-delegation-rbcd">Resource Based Constrained Delegation (RBCD)</a></strong></li>
</ul>
<hr>
<h1 id="kerberos-delegation"><strong>Kerberos Delegation</strong></h1>

    <img src="/demystify_kerberos_delegation/immagine.jpg"  class="center"  style="border-radius: 8px;"  />


<h2 id="what"><strong>What&rsquo;s Kerberos Delegation?</strong></h2>
<p>Before you begin, if you are not confident with Kerberos, i highly suggest you to start reading my other article called &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/">Not So Brief Overview about Kerberos</a>&rdquo;.</p>
<p>Let&rsquo;s assume a scenario where a domain user authenticates via Kerberos to a &ldquo;Front-End&rdquo; AP (service) such as a Web Application, which, to operate correctly, must interact with a &ldquo;Back-End&rdquo; AP (service) such as a Database or a File Server.</p>
<p>In this scenario, when the domain user authenticated via Kerberos performs a particular action on the Web Application, the Web Application will need to authenticate to the Database to retrieve some personal user data, instead of creating (if possible) an application user with extremely specific permissions for the Web Application to use for the Back-End service (in this case the Database), the issue would be resolved if the Web Application itself were able to authenticate via Kerberos to the &ldquo;Back-End&rdquo; service on behalf of the user; in this way, access could be granted exclusively and automatically to a specific portion of data; the Kerberos protocol allows this behavior and this is called Kerberos Delegation.</p>
<p>We know that the domain user &ldquo;ASTRO\Cosmo&rdquo; will present a TGS Ticket (<a href="/posts/not_so_brief_overview_about_kerberos/#37">KRB_AP_REP</a>) to authenticate to the Web Server, consequently, in a traditional Kerberos scenario, the Web Server CANNOT obtain a TGS Ticket on behalf of the domain user &ldquo;ASTRO\Cosmo&rdquo; to access the SQL Server service, because by design, the Web Server, not knowing the NT Hash (or a secrets) of the &ldquo;ASTRO\Cosmo&rdquo; account, CANNOT request a TGT (<a href="/posts/not_so_brief_overview_about_kerberos/#39">KRB_AS_REQ</a>) from the KDC on behalf of the user to then exchange it for a TGS Ticket specific to the SQL Server service.</p>
<blockquote>
<p>The traditional TGS Ticket that the Web Server receives from the &ldquo;ASTRO\Cosmo&rdquo; user is valid exclusively for the Web Server service (as it will contain the SPN HTTP/Web-Server and not a potential SPN SQL\SQLServer).</p></blockquote>
<p>Below is a diagram representing this situation:</p>

    <img src="/demystify_kerberos_delegation/1.png"  class="center"  style="border-radius: 8px;"  />


<p>The &ldquo;Kerberos Delegation&rdquo; feature alters the traditional Kerberos authentication flow to allow the Web Server to authenticate to the Database service on behalf of the domain user.</p>
<p>There are 3 types of Kerberos Delegation:</p>
<ul>
<li>Unconstrained Delegation</li>
<li>Constrained Delegation (1, 2)</li>
<li>Resource-Based Constrained (RBCD) Delegation</li>
</ul>
<p>I want to highlight that the Kerberos Delegation feature allows solving the &ldquo;<a href="https://techcommunity.microsoft.com/blog/askds/understanding-kerberos-double-hop/395463">Double Hop Problem</a>&rdquo;.</p>
<blockquote>
<p>In a internet-facing web services scenario, the user will generally NOT login via the Kerberos protocol to the Web Application, consequently the Web Application will necessarily need to authenticate to a potential Database using only an dedicated application user; furthermore, depending on the permissions and how it has been configured, the Web Application may have access to the database with administrative or limited permissions; in specific scenarios this could lead to issues.</p></blockquote>
<h2 id="unconstrained-delegation"><strong>Unconstrained Delegation</strong></h2>
<p>The oldest and most dangerous version of Kerberos Delegation is the &ldquo;Unconstrained Kerberos Delegation&rdquo;.</p>
<p>The &ldquo;Unconstrained Kerberos Delegation&rdquo;, in summary, alters the Kerberos protocol by making the Client send to the AP Front End a &ldquo;KRB_AP_REQ&rdquo; packet containing both the TGS Ticket (to access the same AP Front-End that receives this packet) and the TGT Ticket, in this way the &ldquo;Front-End&rdquo; AP will be able to use the domain user’s TGT Ticket to impersonate it in a further Kerberos authentication towards potentially ANY AP in the &ldquo;Back-End&rdquo;.</p>

    <img src="/demystify_kerberos_delegation/2.png"  class="center"  style="border-radius: 8px;"  />


<p>The KDC, in order to use the &ldquo;Unconstrained Kerberos Delegation&rdquo;, requires 2 prerequisites:</p>
<p><strong>1. Configure the &ldquo;Unconstrained Kerberos Delegation&rdquo; on the &ldquo;Front-End&rdquo; AP.</strong></p>
<p><span id =1>
    <img src="/demystify_kerberos_delegation/3.png"  class="center"  style="border-radius: 8px;"  />

</p>
<p>The &ldquo;Unconstrained Kerberos Delegation&rdquo; is configured via <a href="https://serveracademy.com/blog/active-directory-users-and-computers-aduc-installation-and-tutorial/">ADUC</a> by enabling the property &ldquo;Trust this computer for delegation to any service (Kerberos only)&rdquo; on the &ldquo;Computer&rdquo; object that acts as the &ldquo;Front-End&rdquo; AP; since this configuration is potentially dangerous, such action can only be performed by a Domain Admin account or an account with the &ldquo;<a href="https://harmj4.rssing.com/chan-30881824/article60.html">SeEnableDelegationPrivilege</a>&rdquo; permission.</p>
<blockquote>
<p>In reality, even an object of type &ldquo;user&rdquo; (domain account) can be configured with the Kerberos Unconstrained Delegation, in this way such domain account will be able to impersonate another domain account to authenticate against target APs (services), however, to do this it is necessary that such account has at least 1 SPN configured, in fact only in this specific case the &ldquo;Delegation&rdquo; tab will appear inside the property of the user object.</p></blockquote>
<p><span id=25> This configuration sets in the &ldquo;UserAccountControl&rdquo; property of the object in question the flag &ldquo;TRUSTED_FOR_DELEGATION&rdquo; to &ldquo;TRUE&rdquo; / &ldquo;1&rdquo;.</p>
<blockquote>
<p><span id=11>Every object of type &ldquo;User&rdquo; and type &ldquo;Computer&rdquo; has an attribute called &ldquo;<a href="https://activedirectorypro.com/useraccountcontrol-check-and-manage-attribute-value/">UserAccountControl</a>&rdquo;, this attribute is a value that represents the set of <a href="https://learn.microsoft.com/en-us/windows/win32/adschema/a-useraccountcontrol?redirectedfrom=MSDN">flags</a> (configurations) set on the object (the most common are DONT_REQUIRE_PREAUTH, NOT_DELEGATE, etc.), for example 514 indicates that the domain user is disabled.</p></blockquote>
<p>In our <a href="/posts/demystify_kerberos_delegation/#1">example</a> the Kerberos Delegation is configured on the Computer &ldquo;THEPUNISHER&rdquo; which will act as the &ldquo;Front-End&rdquo; AP, this modification is actually reflected on the related Computer Account since it is contained in the &ldquo;Computer&rdquo; object (therefore the Computer Account THEPUNISHER$ will have the flag &ldquo;TRUSTED_FOR_DELEGATION&rdquo; set to &ldquo;TRUE&rdquo; / &ldquo;1&rdquo;), this means that any service started by this computer with the Service Account THEPUNISHER$ (Computer Account) will have the Kerberos Unconstrained Delegation enabled (<a href="/posts/not_so_brief_overview_about_kerberos/#17">so, all services started with the Local Service account such as by default the CIFS service</a>).</p>
<p><span id=4>
    <img src="/demystify_kerberos_delegation/4.png"  class="center"  style="border-radius: 8px;"  />

</p>
<blockquote>
<p>By default ALL Domain Controllers have the Kerberos Unconstrained Delegation enabled.</p></blockquote>
<p><strong>2. Configure the domain user that performs Kerberos authentication to the &ldquo;Front-End&rdquo; AP as &ldquo;relayable&rdquo;.</strong></p>
<p>It is necessary that the domain user that performs Kerberos authentication to the &ldquo;Front-End&rdquo; AP does NOT have the &ldquo;NOT_DELEGATED&rdquo; flag set to &ldquo;TRUE&rdquo; / &ldquo;1&rdquo; in the &ldquo;UserAccountControl&rdquo; property; if it is, then that user is NOT delegable, by default ALL domain users do NOT have this flag enabled and are therefore relayable.</p>

      <img src="/demystify_kerberos_delegation/5.png"  class="center"  style="border-radius: 8px;"  />
  

<br>
<hr>
<br>
<p><strong>Below we see the flow of a Kerberos authentication with &ldquo;Unconstrained Delegation&rdquo; enabled:</strong></p>
<blockquote>
<p>To simplify the creation of the lab, even though this would hardly happen in reality, in the following screenshots the Front-End AP will be the CIFS service hosted on the THEPUNISHER computer (this service, having &ldquo;Local System&rdquo; as Service Account, <a href="/posts/not_so_brief_overview_about_kerberos/#17">in a Kerberos context the Service Account will be the Computer Account THEPUNISHER$</a>), in reality, usually, a Front-End AP could be a Web Application.</p></blockquote>

    <img src="/demystify_kerberos_delegation/6.png"  class="center"  style="border-radius: 8px;"  />


<blockquote>
<p>The &ldquo;KRB_AP_REP&rdquo; packet (<a href="/posts/demystify_kerberos_delegation/#9">&ldquo;AP Front-End&rdquo; -&gt; &ldquo;Client&rdquo;</a> &amp; &ldquo;<a href="/posts/demystify_kerberos_delegation/#10">AP Back-End&rdquo; -&gt; &ldquo;AP Front End</a>&rdquo;) required by the Mutual Authentication could be sent in different times based on the Windows machine version used inside the infrastructure, this is the reason why i have not putted them on the image.</p></blockquote>
<blockquote>
<p><span id=2> Integrity and authenticity verification operations that occur within traditional Kerberos authentication (sending &amp; analyzing the &ldquo;Authenticator&rdquo; along with the related &ldquo;Session Key&rdquo; used to encrypt &amp; decrypt parts of the packet) are also present with Unconstrained Delegation enabled, but in this case they will NOT be mentioned, because they have already been generally described <a href="/posts/not_so_brief_overview_about_kerberos/">previously</a> (for a complete analysis in the context of Unconstrained Delegation see <a href="https://www.youtube.com/watch?v=xDFRUYv1-eU&amp;t=326s">this guide</a>) and because it was preferred to instead emphasize the unique characteristics of Kerberos Unconstrained Delegation.</p></blockquote>
<blockquote>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#40">As already mentioned previously</a>, below we will describe the traditional process where Kerberos with Unconstrained Delegation enabled is used, that is, from an Interactive Logon where a user enters their credentials within a WinLOGON GUI, and then subsequently uses Kerberos again in a Network Logon (roughly using cached credentials) to authenticate to a target service with Kerberos Unconstrained Delegation enabled; that said, in reality, the authentication process can also start in other types of authentications besides the traditional WinLOGON GUI (Interactive Logon).</p></blockquote>
<hr>
<br>
<p><strong>Introduction: Initially, the Client (after the domain user has entered their credentials for an Interactive Logon) makes a request for a TGT Ticket &amp; TGS Session Key (KRB_AS_REQ) to the KDC and it responds (KRB_AS_REP) providing the requested data (if positive, in summary, the Client grants access to the domain user).</strong></p>
<h3 id="1-krb_tgs_req-the-client-provides-its-own-tgt-ticket-to-the-kdc-to-request-the-tgs-ticket"><strong>1. KRB_TGS_REQ The Client provides its own TGT Ticket to the KDC to request the TGS Ticket.</strong></h3>
<p>Now that a domain user has already authenticated to a Client (using Kerberos) and already possesses the TGT with a TGS Session Key, if they need to perform a &ldquo;Network Logon&rdquo; the Kerberos protocol comes into play again, specifically the Client will use the TGT and the TGS Session Key to request another type of ticket called the TGS Ticket.</p>
<p>The Client presents to the KDC (no longer to the AS feature) a KRB_TGS_REQ which in summary contains:</p>

    <img src="/demystify_kerberos_delegation/7.png"  class="center"  style="border-radius: 8px;"  />


<ul>
<li>
<p><strong>Ticket TGT</strong>: The previously received TGT ticket (to exchange it for a TGS Ticket)</p>
</li>
<li>
<p><strong>SPN</strong>: The SPN related to / pointing to the service the Client needs to connect to via SSO is sent in plain-text, in this case it refers to the AP Front-End, such as the SPN &ldquo;HTTP/Charlotte.medin.local&rdquo; or &ldquo;CIFS/THEPUNISHER&rdquo;, in the first one the authentication will be to the HTTP service on the Hostname &ldquo;Charlotte.medin.local&rdquo; while in the second one to the CIFS service on the Hostname THEPUNISHER.</p>
</li>
</ul>
<h3 id="2-krb_tgs_rep-the-kdc-sends-the-tgs-ticket-to-the-client-but-specifying-that-the-requested-service-has-the-kerberos-unconstrained-delegation-enabled"><strong>2. KRB_TGS_REP: The KDC sends the TGS Ticket to the Client BUT specifying that the requested service has the Kerberos Unconstrained Delegation enabled.</strong></h3>
<p>The KDC receives the <a href="/posts/demystify_kerberos_delegation/#1-krb_tgs_req-the-client-provides-its-own-tgt-ticket-to-the-kdc-to-request-the-tgs-ticket">KRB_TGS_REQ</a> packet and after performing the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a> sees that the SPN contained within, in this example &ldquo;CIFS\THEPUNISHER&rdquo;, points to the CIFS service hosted on the computer THEPUNISHER which has as Service Account the &ldquo;Computer Account&rdquo; THEPUNISHER$ (<a href="/posts/not_so_brief_overview_about_kerberos/#17">in Kerberos context</a>), since this &ldquo;Computer Account&rdquo; has the <a href="/posts/demystify_kerberos_delegation/#4">TRUSTED_FOR_DELEGATION flag enabled</a>, it means the CIFS service on the computer THEPUNISHER has Kerberos Unconstrained Delegation, consequently the KDC responds to the Client with a &ldquo;KRB_TGS_REP&rdquo; containing, in summary:</p>

    <img src="/demystify_kerberos_delegation/8.png"  class="center"  style="border-radius: 8px;"  />


<ul>
<li><strong>Ticket TGS</strong>: The TGS Ticket for the AP &ldquo;Front-End&rdquo; (CIFS Service hosted on &ldquo;THEPUNISHER&rdquo;) BUT with the flag &ldquo;OK-AS-DELEGATE&rdquo; set to TRUE</li>
</ul>
<blockquote>
<p>The &ldquo;FORWARDABLE&rdquo; flag is also set to TRUE
<span id=6></p></blockquote>
<h3 id="3-krb_tgs_req-the-client-requests-a"><strong>3. KRB_TGS_REQ: The Client requests a &ldquo;Ticket TGT Forwarded&rdquo; from the KDC.</strong></h3>
<p>The Client receives the packet and after performing the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a> sees that the TGS Ticket received has the &ldquo;OK-AS-DELEGATE&rdquo; flag set to TRUE, this flag indicates to the Client that the service the domain user needs to access, namely the AP Front End, has Kerberos Unconstrained Delegation enabled, consequently the Client sends again a &ldquo;KRB_TGS_REQ&rdquo; containing, in summary:</p>

    <img src="/demystify_kerberos_delegation/9.png"  class="center"  style="border-radius: 8px;"  />


<ul>
<li>
<p><strong>Previously received TGT Ticket</strong>: The previously received TGT Ticket (to exchange it this time for a &ldquo;Forwarded TGT Ticket&rdquo;)</p>
</li>
<li>
<p><strong>Other Data</strong>: Since the Client knows that the AP Front End has &ldquo;Kerberos Unconstrained Delegation&rdquo; configured, it choose to requests a so-called &ldquo;Forwarded TGT Ticket&rdquo;, for this purpose inside this Kerberos packet the Client specifies:</p>
<ul>
<li>
<p>The SPN related to the Kerberos service (KDC) of the Domain Controller which is &ldquo;krbtgt/&lt;domain&gt;&rdquo; (analogous to what happens in a <a href="/posts/not_so_brief_overview_about_kerberos/#39">KRB_AS_REQ</a> but this time in a KRB_TGS_REQ)</p>
</li>
<li>
<p>The &ldquo;FORWARDED&rdquo; flag set to TRUE</p>
</li>
</ul>
</li>
</ul>
<span id=8>
<h3 id="4-krb_tgs_rep-the-kdc-sends-a"><strong>4. KRB_TGS_REP: The KDC sends a &ldquo;Ticket TGT Forwarded&rdquo; to the Client</strong></h3>
<p>The KDC, after performing the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, since it previously sent a <a href="/posts/demystify_kerberos_delegation/#2-krb_tgs_rep-the-kdc-sends-the-tgs-ticket-to-the-client-but-specifying-that-the-requested-service-has-the-kerberos-unconstrained-delegation-enabled">KRB_TGS_REP</a> specifying that the service requested by the Client supports Kerberos Unconstrained Delegation, verifies if within the new <a href="/posts/demystify_kerberos_delegation/#6">KRB_TGS_REQ</a> received the &ldquo;FORWARDED&rdquo; flag is set to TRUE, if positive, the KDC responds to the Client with a &ldquo;KRB_TGS_REP&rdquo; containing, in summary:</p>

    <img src="/demystify_kerberos_delegation/10.png"  class="center"  style="border-radius: 8px;"  />


<ul>
<li><strong>The &ldquo;Forwarded TGT Ticket&rdquo;</strong>: The KDC sends to the Client a so-called &ldquo;Forwarded TGT Ticket&rdquo;, that is a TGT Ticket with the &ldquo;FORWARDED&rdquo; flag set to True (which contains like always the PAC of the Client&rsquo;s domain user).</li>
</ul>
<blockquote>
<p>I want to highlight that the KDC sent a &ldquo;Forwarded TGT Ticket&rdquo; within the encrypted part of a KRB_TGS_REP, in a traditional Kerberos authentication the KDC would issue a TGT Ticket exclusively in a <a href="/posts/not_so_brief_overview_about_kerberos/#9">KRB_AS_REP</a>.</p></blockquote>
<span id=7>
<h3 id="5-krb_ap_req-the-client-attempts-to-access-the-front-end-ap-by-providing-its-own-tgs-ticket-but-also-sharing-the-so-called"><strong>5. KRB_AP_REQ: The Client attempts to access the Front-End AP by providing its own TGS Ticket BUT also sharing the so-called &ldquo;Ticket TGT Forwarded&rdquo;.</strong></h3>
<p>The Client, after the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, in summary, sends a &ldquo;KRB_AP_REQ&rdquo; packet to the AP Front-End (in this case to the CIFS service hosted on the computer THEPUNISHER) containing:</p>

    <img src="/demystify_kerberos_delegation/11.png"  class="center"  style="border-radius: 8px;"  />


<ul>
<li>
<p><strong>Ticket TGS</strong>: A TGS Ticket that points via SPN to the AP Front End (in this example CIFS\THEPUNISHER)</p>
</li>
<li>
<p><strong>Forwarded TGT Ticket</strong>: The &ldquo;Forwarded TGT Ticket&rdquo; that the Client received in the previous &ldquo;<a href="/posts/demystify_kerberos_delegation/#8">KRB_TGS_REP&rdquo;</a>.</p>
</li>
</ul>
<blockquote>
<p>I want to highlight that the &ldquo;Forwarded TGT Ticket&rdquo; sent is contained within the &ldquo;authenticator&rdquo; field of the &ldquo;TGS Ticket&rdquo;.</p></blockquote>
<hr>
<p><strong>So, what happens now?</strong></p>
<p>The AP Front End, now having received the <a href="/posts/demystify_kerberos_delegation/#7">KRB_AP_REQ</a> packet, in summary, after the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, performs the following actions:</p>
<ol>
<li>The AP Front End will allow (<a href="/posts/not_so_brief_overview_about_kerberos/#3">if the AUTHORIZATION phase goes correctly</a>) the Client access to the requested service (in this case the CIFS service hosted on the computer THEPUNISHER), subsequently, depending on the requested service and if mutual authentication is required by the Client, the AP Front End will send a KRB_AP_REP to the Client.</li>
</ol>
<blockquote>
<p><span id=9> In my home lab the KRB_AP_REP packet was sent in this scenario, <a href="https://www.youtube.com/watch?v=xDFRUYv1-eU&amp;t=326s">in this other case</a>, however, the KRB_AP_REP packet was delivered to the Client only at the end of the entire process.</p></blockquote>
<ol start="2">
<li>The AP Front End will now extract the &ldquo;Forwarded TGT Ticket&rdquo; contained within the TGS Ticket and cache it locally to potentially impersonate the Client in future interactions.</li>
</ol>
<hr>
<p><strong>If the AP Front End needs to authenticate to an AP Back End on behalf of the Client, the following actions will occur:</strong></p>
<h3 id="6-krb_tgs_req-the-front-end-ap-provides-the-clients"><strong>6. KRB_TGS_REQ: The Front-End AP provides the Client’s &ldquo;Ticket TGT Forwarded&rdquo; to the KDC to request a TGS Ticket.</strong></h3>
<p>Occasionally, when the AP Front End will need to authenticate to the AP Back End on behalf of the Client, the AP Front End will send to the KDC a &ldquo;KRB_TGS_REQ&rdquo; packet built <a href="/posts/demystify_kerberos_delegation/#1-krb_tgs_req-the-client-provides-its-own-tgt-ticket-to-the-kdc-to-request-the-tgs-ticket">as already indicated previously</a>, with the only difference that the Client’s &ldquo;Ticket TGT Forwarded&rdquo; will be shared instead (it contains the domain user’s PAC), in this way the AP Front End will be able to obtain a valid TGS Ticket to authenticate to the AP in the Back-End on behalf of the Client.</p>
<h3 id="7-krb_tgs_rep-the-kdc-sends-the-tgs-ticket-to-the-front-end-ap"><strong>7. KRB_TGS_REP: The KDC sends the TGS Ticket to the Front-End AP.</strong></h3>
<p>The KDC, in summary, after the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, will provide the AP Front End with a TGS Ticket specific for the AP in the Back End.</p>
<blockquote>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#42">As already said</a>, the PAC of the TGS Ticket is a copy of the PAC contained in the provided TGT Ticket, consequently the TGS Ticket that the KDC will provide to the AP Front End will still belong to the Client.</p></blockquote>
<h3 id="8-krb_ap_req-the-ap-front-end-presents-the-tgs-ticket-to-the-ap-back-end-to-authenticate-on-behalf-of-the-client"><strong>8. KRB_AP_REQ: The AP Front End presents the TGS Ticket to the AP Back End to authenticate on behalf of the Client.</strong></h3>
<p>The AP Front End will send a &ldquo;KRB_AP_REQ&rdquo; packet to the AP Back End, authenticating by essentially sharing the previously received TGS Ticket, since this TGS Ticket belongs to the Client (it contains the domain user’s PAC), the AP Front End will authenticate to the AP Back End on behalf of the Client.</p>
<p>Finally, if the AP Front End requests mutual authentication, the AP Back End will reply to the AP Front End with a &ldquo;KRB_AP_REP&rdquo;.</p>
<blockquote>
<p><span id=10> This is what happens in my home lab, <a href="https://www.youtube.com/watch?t=326&amp;v=xDFRUYv1-eU&amp;feature=youtu.be">in this other case</a> instead, the &ldquo;KRB_AP_REP&rdquo; packet is first sent from the AP Back End to the AP Front End and then <a href="/posts/demystify_kerberos_delegation/#9">as already told</a> another &ldquo;KRB_AP_REP&rdquo; from the AP Front End to the Client.</p></blockquote>
<h2 id="constrained-delegation"><strong>Constrained Delegation</strong></h2>
<p>As we have seen, the &ldquo;Unconstrained Kerberos Delegation&rdquo; can be extremely dangerous since the AP Front End caches the Client’s TGT Ticket and can also impersonate the user towards ANY AP in the Back End, for this reason Microsoft developed a more restrictive (a.k.a &ldquo;Constrained&rdquo;) version of Kerberos Delegation called &ldquo;Constrained Delegation&rdquo;, specifically it supports 2 Kerberos extensions known as <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-sfu/3bff5864-8135-400e-bdd9-33b552051d94">Service For User (S4U)</a>:</p>
<ol>
<li>
<p>Service for User to Proxy (S4U2Proxy): Allows the AP Front End to obtain a TGS Ticket on behalf of the Client in order to use it in an authentication to the AP in the Back End.</p>
</li>
<li>
<p>Service for User to Self (S4U2Self): Allows the AP Front End to obtain a TGS Ticket valid for itself on behalf of any Client, such Ticket can be used by the AP Front End as evidence that the Client has authenticated to it.</p>
</li>
</ol>
<p>By using these Kerberos extensions it is possible to restrict (Constrained) the functionality of Kerberos Delegation by ensuring that the AP Front End can authenticate on behalf of the Client exclusively to a predefined set of APs in the Back End, furthermore, to achieve this, the Client’s TGT Ticket is NOT required and therefore there is no risk of it being cached.</p>
<p>Below there is a diagram showing how the Constrained Delegation works:</p>

    <img src="/demystify_kerberos_delegation/12.png"  class="center"  style="border-radius: 8px;"  />


<p>It is possible to configure Constrained Delegation on the AP Front End in 2 different modes:</p>
<ul>
<li>
<p><strong>Trust this computer for delegation to specified service only (Kerberos only)</strong>: The AP Front End is able to impersonate the Client only if the Client logs into it via Kerberos (it uses the S4U2Proxy extension);this scenario is also called <strong>&ldquo;Kerberos Only&rdquo;</strong>.</p>
</li>
<li>
<p><strong>Trust this computer for delegation to specified service only (Use any authentication protocol)</strong>: The AP Front End is able to impersonate the Client if the Client logs into it with any type of protocol, such as NTLM (it uses the S4U2Self &amp; S4U2Proxy extensions); this scenario is also called <strong>&ldquo;Protocol Transition&rdquo;</strong>.</p>
</li>
</ul>
<p>To analyze with Wireshark ALL the flows that occur during this Constrained Delegation I would have had to create from scratch a lab composed of a Front End Service that accepts a Kerberos authentication and develop within it a logic that triggers an additional Kerberos authentication towards the Back-End Server, since I did not find a quick method on how to do this, the screenshots you will see in this section come from this <a href="https://www.youtube.com/watch?v=gzqq2r6cZjc&amp;t=2779s">awesome guide</a>.</p>
<h2 id="constrained-delegation-kerberos-only"><strong>Constrained Delegation (Kerberos only)</strong></h2>
<p>The KDC, in order to use the &ldquo;Constrained Delegation (Kerberos only)&rdquo;, requires 2 prerequisites:</p>
<p><strong>1. Configure the &ldquo;Constrained Delegation (Kerberos only)&rdquo; on the &ldquo;Front-End&rdquo; AP.</strong></p>
<span id=15>

    <img src="/demystify_kerberos_delegation/13.png"  class="center"  style="border-radius: 8px;"  />


<p>The &ldquo;Constrained Delegation (Kerberos only)&rdquo; is configured via <a href="https://serveracademy.com/blog/active-directory-users-and-computers-aduc-installation-and-tutorial/">ADUC</a> by enabling the property &ldquo;Trust this computer for delegation to specified service only (Kerberos only)&rdquo; on the &ldquo;Computer&rdquo; object that acts as the &ldquo;Front-End&rdquo; AP; since this configuration is potentially dangerous, such action can only be performed by a Domain Admin account or an account with the &ldquo;<a href="https://harmj4.rssing.com/chan-30881824/article60.html">SeEnableDelegationPrivilege</a>&rdquo; permission.</p>
<blockquote>
<p>In reality, even an object of type &ldquo;user&rdquo; (domain account) can be configured with the Kerberos Constrained Delegation (Kerberos only), in this way such domain account will be able to impersonate another domain account to authenticate against target APs (services), however, to do this it is necessary that such account has at least 1 SPN configured, in fact only in this specific case the &ldquo;Delegation&rdquo; tab will appear inside the property of the user object; specifically, the &ldquo;Kerberos Only&rdquo; flow described later will remain unchanged with the only difference that when referring to the Service Account &ldquo;Computer Account,&rdquo; the Service Account &ldquo;User&rdquo; will be used instead.</p></blockquote>
<p>Furthermore, it is mandatory to fill the section indicated just below; with it, the domain administrator is able to restrict (a.k.a constrain) which Back-End APs the Front-End AP can authenticate on behalf of the Client.</p>
<p>This configuration sets in the <a href="/posts/demystify_kerberos_delegation/#11">UserAccountControl</a> property of the AP &ldquo;Front End&rdquo; object the flag &ldquo;msds-allowedtodelegateto&rdquo;, which contains in the form of SPNs all the &ldquo;Back End&rdquo; APs for which the &ldquo;Front End&rdquo; AP has permission to authenticate on behalf of the Client.</p>
<p>In our <a href="/posts/demystify_kerberos_delegation/#15">example</a>, the Kerberos Delegation is configured on the Computer &ldquo;WEB01&rdquo; which will act as the Front-End AP, this modification is actually reflected on the related Computer Account since it is contained in the &ldquo;Computer&rdquo; object, so the Computer Account &ldquo;WEB01$&rdquo; will have the &ldquo;msds-allowedtodelegateto&rdquo; property filled, this means that any service started by this computer with the Service Account WEB01$ (Computer Account) will have &ldquo;Kerberos Constrained Delegation (Kerberos Only)&rdquo; enabled (<a href="/posts/not_so_brief_overview_about_kerberos/#17">so, all services started with the Local Service account such as by default the CIFS service or HTTP like in this example</a>).</p>
<span id=25>

    <img src="/demystify_kerberos_delegation/14.png"  class="center"  style="border-radius: 8px;"  />


<p>In conclusion, all services started with the WEB01$ user, such as in this case the HTTP service (AP Front End), will have &ldquo;Constrained Delegation (Kerberos only)&rdquo; enabled; so, in this scenario, they will be able to authenticate on behalf of the Client exclusively on the CIFS service of the SQL01 computer (AP Back-End).</p>
<p><strong>2. Configure the domain user that performs Kerberos authentication to the &ldquo;Front-End&rdquo; AP as &ldquo;relayable&rdquo;.</strong></p>
<p>It is necessary that the domain user that performs Kerberos authentication to the &ldquo;Front-End&rdquo; AP does NOT have the &ldquo;NOT_DELEGATED&rdquo; flag set to &ldquo;TRUE&rdquo; / &ldquo;1&rdquo; in the &ldquo;UserAccountControl&rdquo; property; if it is, then that user is NOT delegable, by default ALL domain users do NOT have this flag enabled and are therefore relayable.</p>

      <img src="/demystify_kerberos_delegation/5.png"  class="center"  style="border-radius: 8px;"  />
  

<br>
<hr>
<br>
<p><strong>Below we see the flow of a Kerberos authentication with &ldquo;Constrained Delegation (Kerberos only)&rdquo; enabled:</strong></p>

    <img src="/demystify_kerberos_delegation/15.png"  class="center"  style="border-radius: 8px;"  />


<blockquote>
<p>The &ldquo;KRB_AP_REP&rdquo; packet (&quot;<a href="/posts/demystify_kerberos_delegation/#12">AP Front-End&quot; -&gt; &ldquo;Client&rdquo;</a>) &amp; &ldquo;AP Back-End&rdquo; -&gt; &ldquo;AP Front End&rdquo;) required by the Mutual Authentication could be sent in different times based on the Windows computer version used inside the infrastructure, with this flow i choose to put down the most common scenario.</p></blockquote>
<blockquote>
<p><span id=2> Integrity and authenticity verification operations that occur within traditional Kerberos authentication (sending &amp; analyzing the &ldquo;Authenticator&rdquo; along with the related &ldquo;Session Key&rdquo; used to encrypt &amp; decrypt parts of the packet) are also present with Unconstrained Delegation enabled, but in this case they will NOT be mentioned, because they have already been generally described <a href="/posts/not_so_brief_overview_about_kerberos/">previously</a> (for a complete analysis in the context of Unconstrained Delegation see <a href="https://www.youtube.com/watch?v=xDFRUYv1-eU&amp;t=326s">this guide</a>) and because it was preferred to instead emphasize the unique characteristics of Kerberos Unconstrained Delegation.</p></blockquote>
<blockquote>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#40">As already mentioned previously</a>, below we will describe the traditional process where Kerberos with Unconstrained Delegation enabled is used, that is, from an Interactive Logon where a user enters their credentials within a WinLOGON GUI, and then subsequently uses Kerberos again in a Network Logon (roughly using cached credentials) to authenticate to a target service with Kerberos Unconstrained Delegation enabled; that said, in reality, the authentication process can also start in other types of authentications besides the traditional WinLOGON GUI (Interactive Logon).</p></blockquote>
<hr>
<br>
<p><strong>Introduction: Initially, the Client (after the domain user has entered their credentials for an Interactive Logon) makes a request for a TGT Ticket &amp; TGS Session Key (KRB_AS_REQ) to the KDC and it responds (KRB_AS_REP) providing the requested data (if positive, in summary, the Client grants access to the domain user).</strong></p>
<h3 id="1-krb_tgs_req-the-client-provides-its-tgt-ticket-to-the-kdc-to-request-the-tgs-ticket"><strong>1. KRB_TGS_REQ: The Client provides its TGT Ticket to the KDC to request the TGS Ticket.</strong></h3>
<p>Now that a domain user has already authenticated to a Client (using Kerberos) and already holds the TGT Ticket with a TGS Session Key, if there is a need to perform a &ldquo;Network Logon&rdquo; login, the Kerberos protocol comes into play again, specifically the Client will use the TGT Ticket and the TGS Session Key to request another type of ticket called the TGS Ticket.</p>
<p>The Client presents to the KDC (no longer to the AS functionality) a KRB_TGS_REQ which in summary contains:</p>
<ul>
<li>
<p>The Client shares its previously received TGT Ticket (to exchange it for a TGS Ticket)</p>
</li>
<li>
<p>SPN: The SPN related to / pointing to the service that the Client needs to connect to via SSO is sent in plain text, in this case it refers to the AP Front-End, such as the SPN &ldquo;HTTP/WEB01&rdquo;, that is, a request for authentication to the HTTP service present on the hostname &ldquo;WEB01&rdquo; is made.
<span id=23></p>
</li>
</ul>
<h3 id="2-krb_tgs_rep-the-kdc-sends-the-tgs-ticket-to-the-client"><strong>2. KRB_TGS_REP: The KDC sends the TGS Ticket to the Client.</strong></h3>
<p>The KDC receives the KRB_TGS_REQ packet and, after performing the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, sends a &ldquo;KRB_TGS_REP&rdquo; packet containing in summary:</p>
<ul>
<li>The TGS Ticket for the &ldquo;Front End&rdquo; AP (HTTP Service hosted on &ldquo;WEB01&rdquo;)</li>
</ul>
<h3 id="3-krb_ap_req-the-client-attempts-to-access-the-front-end-ap-by-providing-its-tgs-ticket"><strong>3. KRB_AP_REQ: The Client attempts to access the Front-End AP by providing its TGS Ticket</strong></h3>
<p>After the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, the Client, in summary, sends a &ldquo;KRB_AP_REQ&rdquo; packet to the Front-End AP (HTTP service) containing in summary:</p>
<ul>
<li>Ticket TGS: Its own TGS Ticket (<a href="/posts/demystify_kerberos_delegation/#2-krb_tgs_rep-the-kdc-sends-the-tgs-ticket-to-the-client">previously received</a>)</li>
</ul>
<h3 id="4-krb_ap_rep-optional-the-ap-front-end-http-will-allow-the-client-access-to-the-requested-service"><strong>4. KRB_AP_REP (Optional): The AP Front End (HTTP) will allow the Client access to the requested service:</strong></h3>
<p>The AP Front End, now that it has received the KRB_AP_REQ packet, in summary, after the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, will allow (<a href="/posts/not_so_brief_overview_about_kerberos/#3">if the AUTHORIZATION phase goes correctly</a>) the Client access to the requested service (in this case the HTTP service hosted on the WEB01 computer), subsequently, depending on the requested service and if mutual authentication is required by the Client, the AP Front End will send a &ldquo;KRB_AP_REP&rdquo; to the Client.</p>
<blockquote>
<p><span id=12> In my home lab the KRB_AP_REP packet was sent in this way, <a href="https://youtu.be/gzqq2r6cZjc?t=1309">in this other case</a>, however, the KRB_AP_REP packet was delivered to the Client only at the end of the entire process.</p></blockquote>
<hr>
<p><strong>If the AP Front End needs to authenticate to a Back End AP on behalf of the Client, the following actions will take place:</strong></p>
<hr>
<h3 id="5-krb_tgs_req-s4u2proxy--s4uself-request"><strong>5. KRB_TGS_REQ (S4U2Proxy) / S4USelf Request</strong></h3>
<p>Occasionally, when the AP Front End (so the HTTP service) needs to authenticate to the Back End AP (so the CIFS service) on behalf of the Client, the AP Front End will send to the KDC a &ldquo;KRB_TGS_REQ (S4U2Proxy)&rdquo; packet containing, in summary:</p>
<ul>
<li>
<p><strong>The AP Front End shares its own TGT Ticket</strong>:</p>
<p>Every computer joined in a domain, during its startup, will perform a Kerberos authentication using its corresponding Computer Account; consequently the WEB01 computer will also have stored in memory the TGT Ticket of the WEB01$ account.</p>
<p>In this scenario, the AP Front End will send the TGT Ticket of its Computer Account.</p>

      <img src="/demystify_kerberos_delegation/16.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
</ul>
<span id=24>
<ul>
<li>
<p><strong>SPN of the Back-End service:</strong></p>
<p>The SPN related to / pointing to the Back-End service that the Front-End service needs to connect to on behalf of the Client is sent, in this case, it refers to the Back-End AP identified by the SPN &ldquo;CIFS/SQL01&rdquo;, so the CIFS service hosted on the &ldquo;SQL01&rdquo; computer.</p>

      <img src="/demystify_kerberos_delegation/17.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
</ul>
<span id=20>
<ul>
<li>
<p><strong>Client&rsquo;s TGS Ticket:</strong></p>
<p>The TGS Ticket that the Client used to access the AP Front End (HTTP service on the WEB01 computer) will be sent.</p>
<p>This TGS Ticket is contained within the &ldquo;Additional Ticket&rdquo; field:</p>

      <img src="/demystify_kerberos_delegation/18.png"  class="center"  style="border-radius: 8px;"  />
  

<p><span id=21> Additionally, it should be noted that the sent TGS Ticket will have the &ldquo;Forwardable&rdquo; flag set to &ldquo;1&rdquo;; by default, all TGS Tickets have this characteristic, that said, in this scenario this flag will be interpreted and therefore it is important to specify it.</p>

      <img src="/demystify_kerberos_delegation/19.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
</ul>
<span id=22>
<ul>
<li>
<p><strong>The flags &ldquo;Resource-Based Constrained-Delegation&rdquo; &amp; &ldquo;Constrained-Delegation&rdquo; both set to &ldquo;1&rdquo; / &ldquo;TRUE&rdquo;:</strong></p>
<p>The AP Front End, within the KRB_TGS_REQ packet, will set the flags &ldquo;Resource-Based Constrained-Delegation&rdquo; &amp; &ldquo;Constrained-Delegation&rdquo; both to &ldquo;1&rdquo; / &ldquo;TRUE&rdquo;; this is done because in case of a FallBack, so if the &ldquo;Constrained Delegation (Kerberos only)&rdquo; fails, the Delegation can proceed with &ldquo;Resource-Based Constrained Delegation (RBCD) flow&rdquo;.</p>
<p>
      <img src="/demystify_kerberos_delegation/20.png"  class="center"  style="border-radius: 8px;"  />
  

<br>

      <img src="/demystify_kerberos_delegation/21.png"  class="center"  style="border-radius: 8px;"  />
  
</p>
</li>
</ul>
<h3 id="6-krb_"><strong>6. KRB_TGS_REP (S4U2Proxy) / S4USelf Response</strong></h3>
<p>The KDC, after performing authenticity checks and analyzing the KRB_TGS_REQ (S4U2Proxy) packet received from the AP Front, will perform further verifications <strong>sequentially</strong>:</p>
<ol>
<li>The KDC verifies if the <a href="/posts/demystify_kerberos_delegation/#20">&ldquo;TGS Ticket&rdquo; used by the Client to access the AP Front End (HTTP/WEB01)</a> is inside in the received <a href="/posts/demystify_kerberos_delegation/#5-krb_tgs_req-s4u2proxy--s4uself-request">KRB_TGS_REQ (S4U2Proxy)</a> packet, which would provide to the KDC the evidence that the Client has indeed authenticated to the AP Front End (HTTP Service on the WEB01 machine) (and therefore that the AP Front End can potentially impersonate the Client); it also checks that this TGS Ticket has the &ldquo;FORWARDABLE&rdquo; flag set to &ldquo;1&rdquo;) (<a href="/posts/demystify_kerberos_delegation/#21">positive result in this case</a>)</li>
</ol>
<blockquote>
<p>As detailed by <a href="https://www.youtube.com/watch?t=2487&amp;v=gzqq2r6cZjc&amp;feature=youtu.be">Microsoft&rsquo;s wiki</a>, if the TGS Ticket does NOT have the <a href="/posts/demystify_kerberos_delegation/#21">&ldquo;FORWARDABLE&rdquo; flag</a> set &amp; <a href="/posts/demystify_kerberos_delegation/#22">if the RBDC flag was NOT configured in the KRB_TGS_REQ (S4U2Proxy)</a>, then the KDC would respond with an error (KRB_ERRBADOPTION); instead, if the RBDC flag is set (by default it is), the KDC will attempt to use RBCD Delegation.</p>
<p>In the typical scenario, like the used in our example, the TGS Ticket sent in the KRB_TGS_REQ (S4U2Proxy) will always have the FORWARDABLE flag TRUE, because it was received by a traditionally <a href="/posts/demystify_kerberos_delegation/#23">&ldquo;KRB_TGS_REP&rdquo;</a>, consequently Kerberos Constrained Delegation (Kerberos Only) practically NEVER  fails and so the fallback case where &ldquo;Resource Based Constrained Delegation (RBCD&rdquo;) would be used is extremely rare.</p></blockquote>
<ol start="2">
<li>The KDC, inspecting the <a href="/posts/demystify_kerberos_delegation/#24">SPN contained in the KRB_TGS_REQ (S4U2Proxy) packet</a>, will understand that the AP Front End (ex HTTP/WEB01) intends to authenticate to a specific AP Back-End (ex CIFS/SQL01) on behalf of the Client; consequently, the KDC retrieves the Service Account of the AP Front End (WEB01$) and checks if the SPN of the requested AP Back End (in this case CIFS/SQL01) is present in its &ldquo;msds-allowedtodelegateto&rdquo; property (<a href="/posts/demystify_kerberos_delegation/#25">positive result in this case</a>)</li>
</ol>
<p>If both verifications are positive, as in our case, then the KDC sends a KRB_TGS_REP (S4U2Proxy) packet to the AP Front End containing, in summary:</p>
<ul>
<li>
<p><strong>A TGS Ticket of the Client to access the AP Back-End</strong>:</p>
<p>The KDC then sends within a &ldquo;KRB_TGS_REP (S4U2Proxy)&rdquo; a TGS Ticket belonging to the Client (containing the PAC of the domain user who authenticated to the AP Front End - inside the image, in the field dedicated to the user name i just wrote a placeholder to avoid a screenshot madness) valid for the AP Back-End (CIFS/SQL01)</p>

      <img src="/demystify_kerberos_delegation/22.png"  class="center"  style="border-radius: 8px;"  />
  

<p>Furthermore, i want to highlight that the TGS Ticket sent will have the &ldquo;Forwardable&rdquo; flag set to &ldquo;1&rdquo;, by default this characteristic is present in ALL TGS Tickets; that said, in this scenario the flag will be interpreted and therefore it is important to clarify.</p>

      <img src="/demystify_kerberos_delegation/23.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
</ul>
<h3 id="7-krb_ap_req"><strong>7. KRB_AP_REQ:</strong></h3>
<p>The AP Front End (HTTP service), after the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a>, in summary, sends a &ldquo;KRB_AP_REQ&rdquo; packet to the AP Back-End (CIFS service) containing, in summary:</p>
<ul>
<li><strong>The previously received TGS Ticket</strong>: The previously received TGS Ticket, that is, the one belonging to the Client (containing the PAC of the domain user who authenticated to the AP Front End) and valid for the AP Back-End (CIFS/SQL01).</li>
</ul>
<h3 id="8-krb_ap_rep-optional"><strong>8. KRB_AP_REP (Optional)</strong></h3>
<p>The AP Back-End, now having received the KRB_AP_REQ packet from the AP Front-End, in summary, after the <a href="/posts/demystify_kerberos_delegation/#2">usual checks</a> (<a href="/posts/not_so_brief_overview_about_kerberos/#3">if the AUTHORIZATION phase goes correctly</a>, will allow access by the AP Front End to the requested service (in this case the CIFS service hosted on the SQL01 machine); subsequently, depending on the requested service and if mutual authentication is required by the AP Front End (ex HTTP service), the AP Back-End (ex CIFS service) will send a KRB_AP_REP to the AP Front End (ex HTTP service).</p>
<blockquote>
<p>This is what happens in my home lab; <a href="https://www.youtube.com/watch?t=1309&amp;v=gzqq2r6cZjc&amp;feature=youtu.be">in this case</a>, however, the &ldquo;KRB_AP_REP&rdquo; packet is sent first by the AP Back-End to the AP Front-End and then  (<a href="/posts/demystify_kerberos_delegation/#12">as already told</a>) another &ldquo;KRB_AP_REP&rdquo; is sent from the AP Front End to the Client.</p></blockquote>
<p>In this way, the AP Front-End has successfully authenticated to the AP Back-End on behalf of the Client.</p>
<h2 id="constrained-delegation-use-any-authentication-protocol--protocol-transition"><strong>Constrained Delegation (Use any authentication Protocol) / Protocol Transition</strong></h2>
<p>In a &ldquo;<a href="/posts/demystify_kerberos_delegation/#constrained-delegation-kerberos-only">Constrained Delegation (Kerberos Only)</a>&rdquo; the AP Front End (ex HTTP) can use the S4U2Proxy extension to obtain from the KDC the Client’s TGS Ticket (ex MARVEL\pparker) to access the AP Back End (ex CIFS); to do this, the AP Front End (ex HTTP) must share the TGS Ticket that the Client (ex MARVEL\pparker) used to authenticate to it, that said, if the AP Front End (ex HTTP) does NOT have such TGS Ticket because the Client authenticated using, for example, NTLM or Basic authentication, this method cannot be used, and for this reason the &ldquo;S4USelf&rdquo; extension was created.</p>
<p>In this scenario the AP Front End (ex HTTP) can invoke the S4U2Self extension, in other words, it requests from the KDC a TGS Ticket of a specific Client (ex MARVEL\pparker) valid exclusively for itself (ex HTTP), this can then be used by the AP Front End as &ldquo;evidence&rdquo; to subsequently invoke the S4U2Proxy extension; this scenario is called &ldquo;Constrained Delegation (Use any authentication protocol)&rdquo;.</p>
<p>The KDC, in order to use the &ldquo;Constrained Delegation (Kerberos only)&rdquo;, requires 2 prerequisites:</p>
<p><strong>1. Configure the &ldquo;Constrained Delegation (Use any authentication protocol)&rdquo; on the &ldquo;Front-End&rdquo; AP.</strong></p>
<span id=25>

    <img src="/demystify_kerberos_delegation/24.png"  class="center"  style="border-radius: 8px;"  />


<p>The &ldquo;Constrained Delegation (Use any authentication protocol)&rdquo; is configured via <a href="https://serveracademy.com/blog/active-directory-users-and-computers-aduc-installation-and-tutorial/">ADUC</a> by enabling the property &ldquo;Trust this computer for delegation to specified service only (Use any authentication protocol)&rdquo; on the &ldquo;Computer&rdquo; object that acts as the &ldquo;Front-End&rdquo; AP; since this configuration is potentially dangerous, such action can only be performed by a Domain Admin account or an account with the &ldquo;<a href="https://harmj4.rssing.com/chan-30881824/article60.html">SeEnableDelegationPrivilege</a>&rdquo; permission.</p>
<blockquote>
<p>In reality, even an object of type &ldquo;user&rdquo; (domain account) can be configured with the &ldquo;Constrained Delegation (Use any authentication protocol)&rdquo;, in this way such domain account will be able to impersonate another domain account to authenticate against target APs (services), however, to do this it is necessary that such account has at least 1 SPN configured, in fact only in this specific case the &ldquo;Delegation&rdquo; tab will appear inside the property of the user object; specifically, the &ldquo;Kerberos Only&rdquo; flow described later will remain unchanged with the only difference that when referring to the Service Account &ldquo;Computer Account,&rdquo; the Service Account &ldquo;User&rdquo; will be used instead.</p></blockquote>
<p>Furthermore, it is mandatory to fill the section indicated just below; with it, the domain administrator is able to restrict (a.k.a constrain) which Back-End APs the Front-End AP can authenticate on behalf of the Client.</p>
<p>This configuration sets in the <a href="/posts/demystify_kerberos_delegation/#11">UserAccountControl</a> property of the AP &ldquo;Front End&rdquo; object:</p>
<ul>
<li>
<p>The &ldquo;TRUSTED_TO_AUTH_FOR_DELEGATION&rdquo; flag (it is different from <a href="/posts/demystify_kerberos_delegation/#25">TRUSTED_FOR_DELEGATION of Unconstrained Delegation</a>)</p>
</li>
<li>
<p>The &ldquo;msds-allowedtodelegateto&rdquo; flag, which contains in the form of SPNs all the AP &ldquo;Back End&rdquo; services to which the AP &ldquo;Front End&rdquo; is allowed to authenticate on behalf of the Client;</p>
</li>
</ul>
<p>In our <a href="/posts/demystify_kerberos_delegation/#25">example</a>, the Kerberos Delegation is configured on the Computer &ldquo;WEB01&rdquo; which will act as the Front-End AP, this modification is actually reflected on the related Computer Account since it is contained in the &ldquo;Computer&rdquo; object, so the Computer Account &ldquo;WEB01$&rdquo; will have the &ldquo;msds-allowedtodelegateto&rdquo; &amp; &ldquo;TRUSTED_TO_AUTH_FOR_DELEGATION&rdquo; property filled, this means that any service started by this computer with the Service Account WEB01$ (Computer Account) will have &ldquo;Constrained Delegation (Use any authentication protocol)&rdquo; enabled (<a href="/posts/not_so_brief_overview_about_kerberos/#17">so, all services started with the Local Service account such as by default the CIFS service or HTTP like in this example</a>).</p>
<span id=30>

      <img src="/demystify_kerberos_delegation/25.png"  class="center"  style="border-radius: 8px;"  />
  

<p>In conclusion, all services started with the WEB01$ user, such as in this case the HTTP service (AP Front End), will have &ldquo;Constrained Delegation (Use any authentication protocol)&rdquo; enabled; so, in this scenario, they will be able to authenticate on behalf of the Client exclusively on the CIFS service of the SQL01 computer (AP Back-End).</p>
<p><strong>2. Configure the domain user that performs Kerberos authentication to the &ldquo;Front-End&rdquo; AP as &ldquo;relayable&rdquo;.</strong></p>
<p>It is necessary that the domain user that performs Kerberos authentication to the &ldquo;Front-End&rdquo; AP does NOT have the &ldquo;NOT_DELEGATED&rdquo; flag set to &ldquo;TRUE&rdquo; / &ldquo;1&rdquo; in the &ldquo;UserAccountControl&rdquo; property; if it is, then that user is NOT delegable, by default ALL domain users do NOT have this flag enabled and are therefore relayable.</p>

      <img src="/demystify_kerberos_delegation/5.png"  class="center"  style="border-radius: 8px;"  />
  

<br>
<hr>
<br>
<p><strong>Below we see the flow of a Kerberos authentication with Constrained Delegation (Use any authentication protocol) enabled:</strong></p>

    <img src="/demystify_kerberos_delegation/26.png"  class="center"  style="border-radius: 8px;"  />


<blockquote>
<p>The &ldquo;KRB_AP_REP&rdquo; packet (<a href="/posts/demystify_kerberos_delegation/#9">&ldquo;AP Front-End&rdquo; -&gt; &ldquo;Client&rdquo;</a> &amp; &ldquo;<a href="/posts/demystify_kerberos_delegation/#10">AP Back-End&rdquo; -&gt; &ldquo;AP Front End</a>&rdquo;) required by the Mutual Authentication could be sent in different times based on the Windows machine version used inside the infrastructure, this is the reason why i have not putted them on the image.</p></blockquote>
<blockquote>
<p><span id=2> Integrity and authenticity verification operations that occur within traditional Kerberos authentication (sending &amp; analyzing the &ldquo;Authenticator&rdquo; along with the related &ldquo;Session Key&rdquo; used to encrypt &amp; decrypt parts of the packet) are also present with Unconstrained Delegation enabled, but in this case they will NOT be mentioned, because they have already been generally described <a href="/posts/not_so_brief_overview_about_kerberos/">previously</a> (for a complete analysis in the context of Unconstrained Delegation see <a href="https://www.youtube.com/watch?v=xDFRUYv1-eU&amp;t=326s">this guide</a>) and because it was preferred to instead emphasize the unique characteristics of Kerberos Unconstrained Delegation.</p></blockquote>
<blockquote>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#40">As already mentioned previously</a>, below we will describe the traditional process where Kerberos with Unconstrained Delegation enabled is used, that is, from an Interactive Logon where a user enters their credentials within a WinLOGON GUI, and then subsequently uses Kerberos again in a Network Logon (roughly using cached credentials) to authenticate to a target service with Kerberos Unconstrained Delegation enabled; that said, in reality, the authentication process can also start in other types of authentications besides the traditional WinLOGON GUI (Interactive Logon).</p></blockquote>
<hr>
<br>
<h3 id="1-client-authenticates-to-an-ap-front-end-not-using-kerberos"><strong>1. Client authenticates to an AP Front End NOT using Kerberos.</strong></h3>
<p>A domain user authenticates to an AP Front End NOT using the Kerberos protocol (NTLM, Basic, etc).</p>
<p><strong>If the AP Front End needs to authenticate to an AP Back End on behalf of the Client, the following actions will take place:</strong></p>
<h3 id="2-krb_tgs_req-s4u2self--s4uself-request"><strong>2. KRB_TGS_REQ (S4U2Self) / S4USelf Request.</strong></h3>
<p>Occasionally, when the AP Front End (ex HTTP service) needs to authenticate to the AP Back End (ex CIFS service) on behalf of the Client (ex CAPSULE.corp\vegeta), since the Client (ex CAPSULE.corp\vegeta) authenticated using, for example, the NTLM protocol, the AP Front End will NOT have the Client’s TGS Ticket and therefore will NOT be able to invoke S4U2Proxy as in the <a href="/posts/demystify_kerberos_delegation/#constrained-delegation-kerberos-only">Constrained Delegation (Kerberos Only)</a> scenario, consequently the AP Front End will resort to the &ldquo;S4U2Self&rdquo; extension, that is, it will send to the KDC a &ldquo;KRB_TGS_REQ&rdquo; packet containing, in summary:</p>
<p>Note: The S4U2Self extension in summary serves to obtain a TGS Ticket belonging to a specific Client (ex CAPSULE.corp\vegeta) valid for the service itself, namely for the AP Front End (ex HTTP).</p>
<h2 id="beahviour-change-about-kerberos-delegation-on-modern-windows-system">Beahviour Change about Kerberos Delegation on Modern Windows System</h2>
]]></content></item><item><title>Not So Brief Overview about Kerberos</title><link>https://marcozufferli.github.io/posts/not_so_brief_overview_about_kerberos/</link><pubDate>Thu, 11 Sep 2025 17:20:24 +0200</pubDate><guid>https://marcozufferli.github.io/posts/not_so_brief_overview_about_kerberos/</guid><description>&lt;img src="https://marcozufferli.github.io/not_so_brief_overview_about_kerberos/immagine.jpg" class="center" style="border-radius: 8px;" /&gt;
&lt;h1 id="kerberos-authentication-protocol"&gt;&lt;strong&gt;Kerberos Authentication Protocol&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;Kerberos is the Windows network authentication protocol present by default in versions after Windows 2000; it replaces the NTLM protocol (specifically, &lt;a href="https://it.wikipedia.org/wiki/NTLM#NTLMv2"&gt;NTLMv2&lt;/a&gt;) but it should be noted that it can only operate in Active Directory contexts and NOT in &lt;a href="https://en.wikipedia.org/wiki/Workgroup_%28computer_networking%29"&gt;Workgroup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In a traditional Active Directory authentication scenario, when a user performs a domain authentication on a WorkStation / Server (Interactive Logon) the Client uses the Kerberos protocol for authentication and if, subsequently, the domain user already logged into the Client needs to authenticate with their domain credentials towards a target network service such as SMB (Network Logon), the Kerberos protocol, having SSO capabilities, is used again by the Client.&lt;/p&gt;</description><content type="html"><![CDATA[
    <img src="/not_so_brief_overview_about_kerberos/immagine.jpg"  class="center"  style="border-radius: 8px;"  />


<h1 id="kerberos-authentication-protocol"><strong>Kerberos Authentication Protocol</strong></h1>
<p>Kerberos is the Windows network authentication protocol present by default in versions after Windows 2000; it replaces the NTLM protocol (specifically, <a href="https://it.wikipedia.org/wiki/NTLM#NTLMv2">NTLMv2</a>) but it should be noted that it can only operate in Active Directory contexts and NOT in <a href="https://en.wikipedia.org/wiki/Workgroup_%28computer_networking%29">Workgroup</a>.</p>
<p>In a traditional Active Directory authentication scenario, when a user performs a domain authentication on a WorkStation / Server (Interactive Logon) the Client uses the Kerberos protocol for authentication and if, subsequently, the domain user already logged into the Client needs to authenticate with their domain credentials towards a target network service such as SMB (Network Logon), the Kerberos protocol, having SSO capabilities, is used again by the Client.</p>
<p>In a Microsoft Active Directory domain, Kerberos is the primary authentication mechanism, for both Interactive Logon and Network Logon (actually also for other LogonTypes), that said, if for any reason the Kerberos protocol CANNOT operate (as when performing a network authentication specifying an IP as the <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#ntlm-in-active-directory">target and not a hostname in Windows utilities</a>, and in fact this is a method to force NTLMv2 authentication over Kerberos) Windows will use the previously available network authentication protocol, that is (usually) NTLMv2; that said, in this section we will detail the Kerberos protocol in all its phases, starting from a scenario that unfolds with an Interactive Logon up to a possible Network Logon.</p>
<p>Kerberos works over the TCP and UDP protocol in clear-text, in fact there is no possibility to implement encryption of the entire communication channel using OpenSSL, this is because it is the Kerberos protocol itself that is responsible for encryption, consequently the encryption mechanism of the Kerberos protocol consists of sending a series of partially already encrypted packets within an unencrypted connection (communication channel).</p>
<p>Kerberos is an authentication protocol, not an authorization protocol, this means that the Kerberos protocol, through the use of TGT, TGS tickets and other related data, is able both to prove to the remote service that the domain user trying to access is indeed a valid domain user, already authenticated and present in the AD (Network Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#1">link</a>), and to the Client when the user performs a standard login to the machine (Interactive Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#2">link</a>); instead, authorization, so the verification of the permissions in order to access to the target service is the responsibility of the AP, that is the server hosting the service (Network Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#3">link</a>), while to the Client it&rsquo;s the responsibility of the Client itself (Interactive Logon) (<a href="/posts/not_so_brief_overview_about_kerberos/#4">link</a>).</p>
<p>Kerberos implements the concept of &ldquo;Ticket&rdquo;, they are &ldquo;objects&rdquo; that will be used to perform domain authentications.
This protocol is called Kerberos, like the three-headed dog of Greek mythology, because in its complete operation (for example from Interactive Logon to Network Logon) it involves 3 distinct actors:</p>
<ul>
<li>
<p><strong>Client / User</strong>: The Client (it&rsquo;s also possible to say the user who has logged into the Client) wants to access a service that requires domain authentication.</p>
</li>
<li>
<p><strong>Application Server (AP)</strong>: The service that the client (or user) wants to access.</p>
</li>
<li>
<p><strong>Key Distribution Center (KDC)</strong>: The Kerberos protocol, to operate, requires the involvement of a Third Party called the Key Distribution Center, which is a functionality of the DC and will be the true core of the protocol and the responsible entity (through its features) for issuing the different Tickets.</p>
<p><span id="7">Specifically, the KDC supports a functionality called Authentication Server (AS), this feature is the one that will actually issue the Tickets called TGT, in some guides it is also said that the KDC has another functionality called Ticket-Granting Server which will be responsible for issuing the other type of Ticket, that is the TGS, that said, for simplicity in this section, instead of specifying the Ticket-Granting Server we will say that it is the KDC itself that issues the TGS.</p>
</li>
</ul>
<p>The Active Directory of a Domain Controller will act as the KDC and the listening ports that expose the service (and therefore the functionalities) of Kerberos will be 88 TCP and 88 UDP.</p>
<p><strong>Kerberos Flow:</strong></p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_flow.png"  class="center"  style="border-radius: 8px;"  />


<blockquote>
<p><span id=40> In the following sections we&rsquo;ll describe the traditional process where Kerberos is used, so from an Interactive Logon where a user enters their credentials within a WinLOGON GUI, to a subsequent Network Logon (using the credentials cached) to authenticate to a target service; in reality, the Kerberos authentication process can actually also begin using other <a href="https://www.alteredsecurity.com/post/fantastic-windows-logon-types-and-where-to-find-credentials-in-them">Logon Type</a> besides the traditional WinLOGON GUI (Interactive Logon), for example: performing a Kerberos authentication to a service (for instance the SMB service using the PsExec utility from Sysinternals) specifying domain credentials that are different from the ones currently in use; since the Client does NOT have the TGT Ticket of the requested credentials cached (because it logged into the Client with another account) a full Kerberos authentication will be performed.</p></blockquote>
<h2 id="kerberos-flow---interactive-login"><strong>Kerberos Flow - Interactive Login</strong></h2>
<span id=39>
<ol>
<li>
<h3 id="krb_"><strong>KRB_AS_REQ: Request of the TGT Token from the Authentication Server (AS)</strong></h3>
</li>
</ol>
<p>The Kerberos protocol is (typically) initialized when a user needs to perform an <a href="https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/windows-logon-scenarios#BKMK_InteractiveLogon">Interactive Logon</a> (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#interactive-logon">1</a>) within a Client using domain credentials, that is by filling in the traditional Windows credential form, also called WinLogon GUI.</p>

      <img src="/not_so_brief_overview_about_kerberos/interactive_logon.png"  class="center"  style="border-radius: 8px;"  />
  

<p>To authenticate, the user enters the credentials on the Client (DOMAIN\User &amp; Password) and everywhing will be shared in cleartext with the &ldquo;LSASS&rdquo; process.</p>
<p><span id="6">After that, LSASS delegates the authentication to its SSPs, so some DLLs (APIs) that can be loaded within the &ldquo;lsass.exe&rdquo; process, consequently the LSASS process loads and shares in cleartext the credentials with all the SSPs dedicated to authentication (kerberos.dll - manage Kerberos, msv1_0.dll - manage NTLM Authentication, wdigest.dll - manage Digest); that said, since the LSASS process does NOT know which SSP to use, <a href="https://syfuhs.net/what-happens-when-you-type-your-password-into-windows">it will use them one by one in sequential order until a correct authentication takes place</a>, consequently, since Windows will recognize that it is a domain user entered, it will start with the &ldquo;kerberos.dll&rdquo; DLL, it then calculates the NT hash of the corresponding previously entered password (which it received in plaintext) and after that contacts the AS (Authentication Service which is a feature of the KDC, that is the DC) to request the issuance of a Ticket called &ldquo;TGT&rdquo; and a &ldquo;TGS Session Key&rdquo;, specifically the LSASS process sends a KRB_AS_REQ which contains:</p>

      <img src="/not_so_brief_overview_about_kerberos/krb_as_req.png"  class="center"  style="border-radius: 8px;"  />
  

<ul>
<li>
<p><strong>Authenticator</strong>: the timestamp contained within it will be encrypted with the user’s hash, while other values such as the ‘username’ field, which contains the name of the domain user we are logging in with, will all be in plain-text.</p>
</li>
<li>
<p><span id="5"><strong>SPN - krbtgt</strong>: It will be indicated in the dedicated field, the SPN related to the Kerberos service (KDC) of the Domain Controller which is equal to krbtgt/[&lt;domain&gt;].</p>
<p>A Service Principal Name (SPN), <a href="/posts/not_so_brief_overview_about_kerberos/#service-principal-name-spn">as we explain later</a> is a unique identifier for the instance of a service, SPNs are used by Kerberos authentication to associate the instance of a service (simplifying: the start &amp; running of the service such as for example Microsoft SQL) with a so-called &ldquo;Logon Account&rdquo;, so a domain user (which in this way it will becomes a Service Account); in other terms, (generically speaking) an SPN can be considered as a generic object that represents the association between a service and a domain user, that said, technically, <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">it is an attribute of the &ldquo;Users&rdquo; object</a> and in fact from it one can list the related SPNs; this essentially means that through an SPN it is possible to map the start &amp; the running of a service present on a server with a domain user rather than associating it with a &ldquo;Standard Service Account&rdquo; such as <a href="https://learn.microsoft.com/it-it/windows/win32/services/networkservice-account?redirectedfrom=MSDN">NetworkService Account</a>; finally, it should be noted that also Computer Accounts have SPNs.</p>
<blockquote>
<p><strong>Note 1</strong>: If the DC is not accessible when a Client performs a domain authentication, the Client checks whether such credentials are present within the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/user-profiles-and-logon/cached-domain-logon-information">Domain Credential Cached (DCC)</a> which stores the last domain users logged into the machine (only if a user authenticates correctly and has the permissions to access the Client), if they are also NOT present there then the login is rejected.</p></blockquote>
<blockquote>
<p><strong>Note 2</strong>: As we will see later, if a domain user has the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties">DONT_REQ_PREAUTH</a> flag enabled, the AS will respond with a valid KRB_AS_REP (response) even if the KRB_AS_REQ (request) packet does not have the &ldquo;Timestamp&rdquo; encrypted with the NTHash of the user’s password.</p></blockquote>
<blockquote>
<p><span id=32> <strong>Note 3</strong>: For simplicity of explanation everything has been described in this way, what will happen in reality is that the Client will first send a &ldquo;KRB_AS_REQ&rdquo; packet to the AS NOT encrypting the Timestamp with the NT Hash of the current user and only when the AS responds with an error &ldquo;KDC_ERR_PREAUTH_REQUIRED&rdquo; then the Client will send a new &ldquo;KRB_AS_REQ&rdquo; with the Timestamp encrypted, this is the <a href="https://youtu.be/4LDpb1R3Ghg?t=3167">reason</a> why by analyzing everything with Wireshark in a traditional Kerberos authentication one can notice such error message.</p></blockquote>
</li>
</ul>
<ol start="2">
<li>
<h3 id="krb_-1"><strong>KRB_AS_REP: AS sends the TGT token to the Client</strong></h3>
</li>
</ol>
<span id="9">
The AS (a feature of the KDC) after having received such request, using the username (which is not encrypted) as a keyword searches inside its Database for the password of that user in order to decrypt the message; if the AS correctly decrypts the message and the now decrypted timestamp falls within the time difference configured in the KDC, then the authentication has occurred successfully.
<blockquote>
<p>If the domain user contained in the first KRB_AS_REQ interaction has the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties">DONT_REQ_PREAUTH</a> property flag enabled, the AS will accept such authentication request as valid EVEN if the request does NOT have the &ldquo;timestamp&rdquo; value encrypted with the NT Hash of the domain user, in such case the AS will simply verify directly whether the timestamp falls within the time difference configured in the KDC; it is important to underline that if the domain user has such flag enabled, the AS will nevertheless respond with a valid KRB_AS_REP both if the KRB_AS_REQ packet has the &ldquo;timestamp&rdquo; encrypted (usually sent by the LSASS process in an Interactive Logon) and if it does NOT have the timestamp encrypted (usually sent by an attacker if performing an AS-REP Roasting Attack).</p></blockquote>
<p>If everything goes well, the AS responds to the client with a packet called KRB_AS_REP containing the TGT Ticket and the TGS Session Key (called &ldquo;Session Key&rdquo; within the screenshot), such TGS Session Key will be used subsequently as an encryption key for the possible following requests.</p>
<p>The KRB_AS_REP packet sent by the AS to the Client contains:</p>
<p><span id="12">
    <img src="/not_so_brief_overview_about_kerberos/krb_as_rep.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li>
<p><strong>Ticket TGT</strong>: The TGT Ticket which has been encrypted with the &ldquo;krbtgt hash&rdquo;, that is the hash (NT Hash) of the domain user called &ldquo;krbtgt&rdquo; (<a href="/posts/not_so_brief_overview_about_kerberos/#5">as previously specified</a>)
<span id="8">Since the Client for obvious reasons does not know the password hash of the KDC it cannot decrypt the TGT Ticket, this is not a problem because to obtain the TGS Ticket in the next step it is sufficient to send the TGT ticket as we received it, that is, encrypted.</p>
</li>
<li>
<p><strong>Other Data</strong>: Other various data, including the TGS Session Key, are encrypted with the hash (NT Hash) of the Client user who requested the domain authentication via Interactive Logon; in this way the KRB_AS_REP packet when sent by the AS to the Client even if intercepted via Man-In-The-Middle Attack, the attacker could not (hopefully 😉) decrypt the packet since they do not know the hash of the Client user.</p>
</li>
</ul>
<blockquote>
<p>The AS will respond to the Client by sending a KRB_AS_REP with the TGS Session Key (plus other data) encrypted with the NTHash of the domain user regardless of whether it has the <a href="https://learn.microsoft.com/en-us/troubleshoot/windows-server/active-directory/useraccountcontrol-manipulate-account-properties">DONT_REQ_PREAUTH</a> flag enabled or not, such behavior will lead to an AS-REP Roasting type attack.</p></blockquote>
<hr>
<p><strong>So, what happens now?</strong></p>
<p>Below are the sequential steps that occur until the user’s home screen is loaded:</p>
<ul>
<li><span id="2"><strong>Authentication</strong>: The Client has now obtained the KRB_AS_REP packet, consequently the LSASS process (or rather its SSP that established the connection, namely &ldquo;Kerberos.dll&rdquo;) performs the decryption of the portion of the KRB_AS_REP packet encrypted with the NT Hash of the domain account performing the authentication (this is because the Client intrinsically knows this value); if this activity is done correctly it means that the authentication has succeeded and for this reason the Kerberos AUTHENTICATION process ends.</li>
</ul>
<blockquote>
<p>It should be noted that the Client stores in memory the TGT Ticket received, this is the reason why if an attacker compromises this machine, they are able to perform a Pass-The-Ticket (PtT).</p></blockquote>
<ul>
<li>
<p><span id="4"><strong>Authorization</strong>: The Client now needs to understand if the domain account authenticated via Kerberos has the authorizations to access, <a href="https://syfuhs.net/what-happens-when-you-type-your-password-into-windows">in order to do this</a>, it should retrieve the information of the authenticated account by inspecting the &ldquo;PAC&rdquo; contained in the received TGT Ticket, but, unfortunately, the PAC contained within the received TGT Ticket is inaccessible since the TGT Ticket is encrypted with the &ldquo;krbtgt&rdquo; hash, consequently, similarly to what happens in a Network Logon scenario (<a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---network-logon">as we will see later</a>), also in this Interactive Logon case, the Client will request a TGS Ticket BUT indicating in the dedicated field an <a href="https://en.hackndo.com/service-principal-name-spn/#edge-case---host">SPN of type &ldquo;HOST&rdquo;</a> related to the Client machine (ex: HOST\Workstation01&quot;) involved, since (1) the service account associated with the Client (ex: Workstation01) is its corresponding <a href="/posts/not_so_brief_overview_about_kerberos/#relationship-between-a-spn--computer-account">&ldquo;Computer Account&rdquo;</a> (ex: DOMAIN\Workstation01$), it will be possible to decrypt the TGS Ticket, extract the PAC and perform the authorization verification:</p>
<ol>
<li><strong>First Authorization Phase</strong>: The SSP &ldquo;kerberos.dll&rdquo; (so the Client) will send a KRB_TGS_REQ packet to the DC in order to request a TGS Ticket; instead of indicating an SPN of a target service (<a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---network-logon">as we will show later in the context of Network Logon</a>) it will indicate the &ldquo;HOST&rdquo; SPN related to the Client machine itself, so where the authentication has just taken place (ex: &ldquo;HOST\Workstation01&rdquo;); in this way the DC will respond with a KRB_TGS_REP containing a TGS Ticket encrypted with the Client’s domain account &ldquo;Computer Account&rdquo; (ex: DOMAIN\Workstation01$), since the LSASS process of the Client has in memory (specifically in the <a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/lsa-logon-session">LOGON SESSION</a>) the NT Hash of every Security Principal (every authenticated account) of the machine, including also its own <a href="/posts/not_so_brief_overview_about_kerberos/#relationship-between-a-spn--computer-account">&ldquo;Computer Account&rdquo;</a> (ex: DOMAIN\Workstation01$), it will use the NT Hash of such domain account to decrypt the TGS Ticket and then extract in plaintext the PAC contained within it (the PAC is simply &ldquo;signed&rdquo; by the DC with the &ldquo;krbtgt hash&rdquo;, not encrypted) with which it will perform the analysis related to authorizations.</li>
</ol>
<blockquote>
<p>The reason why this step is NOT usually described in a Kerberos authentication articles, is that the Kerberos authentication flow is often captured (from a Windows machine) by <a href="/posts/not_so_brief_overview_about_kerberos/#35">sniffing the network traffic with Wireshark after performing a &ldquo;klist purge&rdquo;</a> (by removing the TGT Ticket, the Client during a Kerberos authentication will necessarily have to re-perform a complete Kerberos authentication); with this procedure, this specific step will NOT be executed because the domain account since is already authenticated on the Client, the Client will NOT need to perform again the AUTHORIZATION check and for this reason it will NOT send this packet during the sniffing.</p></blockquote>
<ol start="2">
<li><strong>Second Authorization Phase</strong>: Another component of the LSASS process will compare the content of the PAC (SID, Group &amp; etc. related to the domain account logged on to the Client) just extracted against the Client’s ACLs and, if positive, the AUTHORIZATION phase performed by the Client will end.</li>
</ol>
</li>
</ul>
<p><strong>If positive</strong>:</p>
<ol>
<li>
<p>The SSP &ldquo;Kerberos.dll&rdquo; (so the LSASS process) creates a LogonSession (<a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/lsa-logon-sessions">it is a data structure present in LSASS</a>) which will represent the domain account just authenticated (ex: ASTRO\Cosmo)</p>
</li>
<li>
<p>Windows (this action is not performed by Kerberos.dll) will attach to the the LogonSession of the user just created ALL the previously loaded SSPs (even if only &ldquo;kerberos.dll&rdquo; was actively used for the authentication phase in this context), these SSPs <a href="/posts/not_so_brief_overview_about_kerberos/#6">as already mentioned</a>, will contain the authenticated user’s credentials in plaintext; this happens to ensure Network Logon SSO functionality (Kerberos or NTLM) since these network protocol requires the use of the current account’s NT Hash (which is derivable from the plaintext password).</p>
<p>It means that if an attacker is able to dump a Logon Session, he will able to see ALL the associated SSPs along with their stored credentials in plaintext (generally speaking because exist some features that mitigate this logic) (dumpable with <a href="https://adsecurity.org/?page_id=1821">sekurlsa::logonpasswords</a>).</p>
</li>
</ol>
<blockquote>
<p>In reality the MSV SSP (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#ntlm-ssp">1</a>, <a href="https://www.praetorian.com/blog/inside-mimikatz-part1/">2</a>) will instead provide the NT Hash of the password.</p></blockquote>
<ol start="3">
<li><span id="10">The SSP &ldquo;Kerberos.dll&rdquo; (so the LSASS process) caches the TGT Ticket + TGS Session key inside the Logon Session of the authenticated account (ex: ASTRO\Cosmo) (dumpable with <a href="https://adsecurity.org/?page_id=1821">sekurlsa::tickets</a>)</li>
</ol>
<blockquote>
<p>Since Logon Sessions are created and destroyed dynamically based on user logins and logoffs, an attacker could obtain the NT Hash of a user account (local or domain) only if it is currently logged on (or recently logged on) by dumping the corresponding Logon Session (sekurlsa::logonpasswords) (because the Logon Session still exists inside the memory); the same principle applies also to all the others secrets stored in the Logon Session like for example dumping the Kerberos tickets (sekurlsa::tickets).</p></blockquote>
<ol start="4">
<li>
<p>The SSP &ldquo;Kerberos.dll&rdquo; (so the LSASS process) caches a hashed version (MSCACHEV2/MSCASH hashes) of the password of the authenticated account (ex: ASTRO\Cosmo) inside the Domain Credential Cached (DCC) (dumpable <a href="https://adsecurity.org/?page_id=1821">lsadump::cache</a>)</p>
</li>
<li>
<p>The domain user (e.g ASTRO\Cosmo) <strong>finally</strong> loads the home screen
Since the TGT Ticket and the TGS Session Key have been cached, if a Network Logon attempt occurs Kerberos will be used again.</p>
</li>
</ol>
<p>If a domain user already logged on to the Client (using Kerberos) needs to authenticate to a target network service and thus perform a &ldquo;Network Logon&rdquo; type login, since the Kerberos protocol is SSO (Single Sign On), the following steps are followed.</p>
<hr>
<h2 id="kerberos-flow---network-logon"><strong>Kerberos Flow - Network Logon</strong></h2>
<ol start="3">
<li>
<h3 id="krb_-2"><strong>KRB_TGS_REQ: The Client provides the KDC with its TGT Ticket to request the TGS Ticket</strong></h3>
</li>
</ol>
<p>Now that a domain user has already authenticated to a Client (using Kerberos) and already possesses the TGT Ticket with a TGS Session Key, if they need to perform a &ldquo;Network Logon&rdquo; type login, the Kerberos protocol comes into play again, specifically the Client will use the TGT ticket and the TGS Session Key to request another type of ticket called the TGS Ticket.</p>
<blockquote>
<p>The TGS Ticket has been called in this way in many publications because it is issued by the Ticket-Granting Services feature (of the KDC) which has the acronym TGS, which, for simplicity of explanation (<a href="/posts/not_so_brief_overview_about_kerberos/#7">as already mentioned</a>) in these diagrams instead of specifying that the TGS is issued by the Ticket-Granting Services it was simply said it&rsquo;s issued by the KDC; that said, looking inside the <a href="https://datatracker.ietf.org/doc/html/rfc4120/">RFC4120</a> we can understand that in reality the real name of the TGS Ticket is Service Ticket (ST), this is the reason why in other publications (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#st">1</a>, <a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">2</a>) this type of Ticket is referred to by this other name.</p></blockquote>
<p>The Client presents to the KDC (no longer to the AS functionality) a KRB_TGS_REQ which essentially contains:</p>
<p><span id=13>
    <img src="/not_so_brief_overview_about_kerberos/krb_tgs_req.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li>
<p><strong>Ticket TGT</strong>: The <a href="/posts/not_so_brief_overview_about_kerberos/#8">previously received</a> TGT ticket.</p>
<blockquote>
<p>It has never been decrypted, is sent to the client encrypted as obtained previously, that is, encrypted with the &ldquo;krbtgt hash&rdquo;.</p></blockquote>
</li>
<li>
<p><strong>Authenticator</strong>: Username (domain user who made the request) &amp; Timestamp, both encrypted with the TGS Session Key (obtained with KRB_AS_REP <a href="/posts/not_so_brief_overview_about_kerberos/#10">which was decrypted and cached previously during the Interactive Logon operation</a>.</p>
</li>
<li>
<p><span id=16> <strong>SPN</strong>: The SPN related to / pointing to the service the Client needs to connect to via SSO is sent in plain-text, such as the SPN &ldquo;HTTP/Charlotte.medin.local&rdquo; or &ldquo;CIFS/SERV01&rdquo; (<a href="https://en.hackndo.com/kerberos/">1</a>); in the first, one wants to authenticate to the HTTP service present on the Hostname &ldquo;Charlotte.medin.local&rdquo; while in the second to the CIFS service present on the Hostname SERV01.</p>
</li>
</ul>
<p><span id=18>I want to highlight that both TGT Ticket &amp; TGS Ticket (also called Service Ticket / ST ) contain the <a href="/posts/not_so_brief_overview_about_kerberos/#privilege-attribute-certificate-pac">Privilege Attribute Certificate (PAC)</a>, that is, a data structure used by the Kerberos protocol to share with the other actors involved in the authentication the security information related to the domain user attempting the login, including: Username, ID, Group Membership and in general all security information; furthermore <a href="/posts/not_so_brief_overview_about_kerberos/#11">the PAC is NOT encrypted but ONLY signed</a>.</p>
<ol start="4">
<li>
<h3 id="krb_-3"><strong>KRB_TGS_REP: KDC sends the TGS Ticket to the client</strong></h3>
</li>
</ol>
<p>The KDC, after having received the packet from the Client, being in possession of the &ldquo;krbtgt hash&rdquo; decrypts the received TGT Ticket and extracts the TGT Owner (<a href="/posts/not_so_brief_overview_about_kerberos/#12">&ldquo;username&rdquo; field of the TGT</a>) &amp; the related <a href="/posts/not_so_brief_overview_about_kerberos/#12">TGS Session Key</a>, then it uses such extracted TGS Session Key to decrypt the Authenticator received in that packet (<a href="/posts/not_so_brief_overview_about_kerberos/#13">KRB_TGS_REQ</a>), if everything goes well and the &ldquo;Username&rdquo; field (contained in <a href="/posts/not_so_brief_overview_about_kerberos/#13">KRB_TGS_REQ</a>) matches the TGT Owner (<a href="/posts/not_so_brief_overview_about_kerberos/#12">&ldquo;username&rdquo; field of the TGT Ticket</a>) and the timestamp is valid, then the KDC verifies whether the PAC contained in the received TGT Ticket is valid (the KDC, having the krbtgt hash, computes a signature on the content of the PAC to verify if such output <a href="/posts/not_so_brief_overview_about_kerberos/#15">matches the signature present in the PAC of the TGT Ticket</a>) and if positive generates the TGS Ticket (Service Ticket / ST); in this way the KDC (DC) has ensured that whoever has made the request for a TGS Ticket has a TGT Ticket with a valid related TGS Session Key and that the PAC is correct.</p>
<p>Once the verification is completed, the KDC sends to the Client the KRB_TGS_REP packet containing:</p>
<p><span id=19>
    <img src="/not_so_brief_overview_about_kerberos/krb_tgs_rep.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li><span id=29><strong>Ticket TGS</strong>: TGS Ticket encrypted with the hash of the service account related to the service that the client wishes to access (called in the image &ldquo;Service Owner Hash&rdquo;), it has been retrieved <a href="/posts/not_so_brief_overview_about_kerberos/#16">using the SPN field configured in the KRB_TGS_REQ packet</a>; for example, if via Kerberos SSO (<a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">Page 15</a>) we requested the SPN &ldquo;HTTP/Charlotte.medin.local&rdquo;, the password of the service account associated with that HTTP service (e.g., DOMAIN\websvc) will be used to encrypt the TGS Ticket, if instead the request was made to the SPN &ldquo;MSSQL/db01.medin.local&rdquo;, the password of the service account associated with that MSSQL service (e.g., DOMAIN\sqlengine) will be used to encrypt the TGS Ticket; another scenario is if the request is made, for example, to the SPN &ldquo;CIFS/serv01&rdquo; (one of the several services usually run with the &ldquo;<a href="https://learn.microsoft.com/it-it/windows/win32/services/localservice-account?redirectedfrom=MSDN">Local Service Account</a>&rdquo; - so a <a href="https://learn.microsoft.com/en-us/windows/security/identity-protection/access-control/local-accounts#default-local-system-accounts">Default Local System Account</a>), in this case as well the password of the related Service Account (<a href="/posts/not_so_brief_overview_about_kerberos/#17">so the Computer Account &ldquo;serv01$&rdquo;</a>) will be used to encrypt the TGS Ticket.</li>
</ul>
<blockquote>
<p>The KDC, being the DC, knows the hashes of all domain users, so also the service accounts (which are domain users) and also the hash of the service account that runs the service requested by the Client.</p></blockquote>
<blockquote>
<p><span id=42>The PAC of the TGS Ticket is a copy of the PAC contained in the <a href="/posts/not_so_brief_overview_about_kerberos/#12">received TGT Ticket</a>; this is one of the behavior that makes it possible to perform a Golden Ticket.</p></blockquote>
<ul>
<li><strong>Other Data</strong>: A &ldquo;Service Session Key&rdquo;, together with other data, encrypted with the TGS Session Key; it will be used as the encryption key for the final packet exchanges.</li>
</ul>
<p>As <a href="/posts/not_so_brief_overview_about_kerberos/#18">already mentioned</a>, the TGS Ticket (also called Service Ticket), like the TGT Ticket, contains the PAC (Privilege Attribute Certificate), that is, a structure contained in every ticket which holds the characteristics of the user (SID, group, etc.); furthermore, it must be specified that the PAC is NOT encrypted but signed.</p>
<ol start="5">
<li>
<h3 id="krb_-4"><strong>KRB_AP_REQ: The Client attempts to access the AP resource by providing its TGS Ticket</strong></h3>
</li>
</ol>
<p><span id=23>The Client decrypts the portion of the <a href="/posts/not_so_brief_overview_about_kerberos/#19">KRB_TGS_REP</a> packet received using the TGS Session Key that the Client had previously received with the <a href="/posts/not_so_brief_overview_about_kerberos/#9">KRB_AS_REP packet</a> and <a href="/posts/not_so_brief_overview_about_kerberos/#10">cached during the Interactive Login phase</a>, by decrypting it obtains the plaintext value of the &ldquo;Service Session Key&rdquo;, which will be used as the key for this exchange between the Client and the AP.</p>
<p>If everything has gone well, the user now has a valid TGS Ticket to use in order to access the target service, once the verification is completed, the actions are:</p>
<p><span id=26>
    <img src="/not_so_brief_overview_about_kerberos/krb_ap_req.png"  class="center"  style="border-radius: 8px;"  />

</p>
<ul>
<li>
<p><strong>Ticket TGS</strong>: The Client sends a packet containing the TGS Ticket (Service Ticket / TS) (which had already previously been encrypted with the hash of the service account of the target service) to the AP.</p>
</li>
<li>
<p><strong>Authenticator</strong>: The packet contains an &ldquo;Authenticator&rdquo; (Username + Timestamp) encrypted with the <a href="/posts/not_so_brief_overview_about_kerberos/#23">Service Session Key, so with the key just extracted</a>.
For synthesis reasons it was <strong>NOT</strong> reported in the image but in reality in the KRB_AP_REQ packet the &ldquo;SPN&rdquo; field is sent again, in this way <a href="/posts/not_so_brief_overview_about_kerberos/#1">subsequently</a> the AP will know which service account hash to retrieve in order to decrypt the TGS Ticket to perform the verification.</p>
</li>
</ul>
<hr>
<p><strong>So, again, what happens now?</strong></p>
<p>The AP, after having received the KRB_AP_REQ packet from the Client, performs the following actions:</p>
<ul>
<li>
<p><span id="1"><strong>Authentication</strong>: The AP, having at its disposal the NT Hash of the service account the Client wishes to authenticate to, uses it to decrypt the received TGS Ticket and extracts the PAC &amp; the TGS Owner (&quot;<a href="/posts/not_so_brief_overview_about_kerberos/#19">username field&quot; of the TGS</a>) &amp; the &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#19">Service Session Key</a>&rdquo;. The AP uses this &ldquo;Service Session Key&rdquo; just extracted to decrypt the Authenticator received in the <a href="/posts/not_so_brief_overview_about_kerberos/#26">KRB_AP_REQ</a> packet, if everything goes well and the &ldquo;Username&rdquo; field of the Authenticator (<a href="/posts/not_so_brief_overview_about_kerberos/#26">contained in KRB_AP_REQ</a>) matches the TGS Owner (&quot;<a href="/posts/not_so_brief_overview_about_kerberos/#19">username field&quot; of the TGS</a>) and the timestamp is valid, the &ldquo;AUTHENTICATION&rdquo; phase of the Kerberos protocol is completed.</p>
<blockquote>
<p>It should be noted that the AP stores the received TGS Ticket in memory, this is the reason why if an attacker compromises that machine, they are able to perform a Pass-The-Ticket (PtT).</p></blockquote>
</li>
<li>
<p><span id="3"><strong>Authorization</strong>: The AP uses the PAC <a href="/posts/not_so_brief_overview_about_kerberos/#1">just extracted</a> from the TGS Ticket (Service Ticket / ST) and uses it to determine whether the domain user in question actually has the permissions to access the service, specifically, since the PAC contains in plain-text (<a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">page 13</a>) (the PAC is simply &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#11">signed</a>&rdquo; by the DC with the &ldquo;krbtgt hash&rdquo;, not encrypted) the security information of the domain user who needs to connect to the service, such as SID, Username, RID and other data, the AP compares this information with the ACLs related to the service, if the outcome is positive the AP will grant the Client access to the service and this <strong>finaly</strong> concludes the &ldquo;AUTHORIZATION&rdquo; phase which I highlight is carried by the AP, so by the service.</p>
</li>
</ul>
<p>As can be seen, the Kerberos protocol validates to the target service (e.g. CIFS/SMBSERVER01) that the domain user who requested access is authenticated and valid (<a href="/posts/not_so_brief_overview_about_kerberos/#1">AUTHENTICATION</a>), while it&rsquo;s the target service itself (e.g. CIFS/SMBSERVER01), or rather the server hosting that service, namely the AP, that is responsible for verifying whether that user has the necessary permissions to access that service (<a href="/posts/not_so_brief_overview_about_kerberos/#3">AUTHORIZATION</a>).</p>
<p>Due to how the Kerberos protocol works, the AP (the server hosting the service such as CIFS to which the domain user needs to authenticate) will NEVER receive the NT Hash of the domain user who authenticated, because the AP will only receive the KRB_AP_REQ packet which does not contain such data, this means that if an attacker exploits the AP, from it they will not be able to recover the domain credentials of the users who have connected via SSO to that service.</p>
<hr>
<p><span id=33><strong>Optional</strong></p>
<p>Although it is not the Kerberos protocol itself but the <a href="https://www.tarlogic.com/blog/how-kerberos-works/">NRPC (NetLogon) protocol</a> (<a href="https://adsecurity.org/?p=1515">1</a>), if the AP needs to verify whether the PAC received (<a href="/posts/not_so_brief_overview_about_kerberos/#26">contained in the TGS Ticket</a>) is valid, <a href="/posts/not_so_brief_overview_about_kerberos/#28">a check that it does not happen often</a>, it can verify it by sending a packet named <a href="https://learn.microsoft.com/en-us/archive/blogs/openspecification/understanding-microsoft-kerberos-pac-validation#kerberos-pac-validation">KERB_VERIFY_PAC_REQUEST</a> as indicated later; furthermore, if the Client explicitly requests it (<a href="https://datatracker.ietf.org/doc/html/rfc1510#section-5.5.1">flag &ldquo;ap-options=1&rdquo;</a> inside the <a href="/posts/not_so_brief_overview_about_kerberos/#26">KRB_AP_REQ packet</a>), the AP must also authenticate itself to the Client, this concent is called &ldquo;Mutual Authentication&rdquo;; if both activities are required, the following steps 6, 7, and 8 will take place, and only after their completion the AP (or rather its service) will grant access to the Client.</p>
<blockquote>
<p><span id=28>I want to highlight that the PAC contained in the TGT Ticket is ALWAYS validated (when the DC receives the KRB_TGS_REQ) while the PAC contained in the TGS Ticket is validated ONLY if properly configured (by configuring a registry which is disabled by default).
In the case where both the PAC verification and the Client request for Mutual Authentication are present, the following steps occur:</p></blockquote>
<ol start="6">
<li>
<h3 id="optional-kerb_"><strong>(Optional) KERB_VERIFY_PAC_REQUEST</strong></h3>
</li>
</ol>
<p>In the case where the service (AP) wants to validate whether the PAC received (contained in the TGS Ticket) is valid, it uses the Netlogon protocol <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/b27be921-39b3-4dff-af4a-b7b74deb33b5">to ask the DC</a> to verify the PAC signature.</p>
<ol start="7">
<li>
<h3 id="optional-pac_"><strong>(Optional) PAC_RESPONSE</strong></h3>
</li>
</ol>
<p>The DC will verify if the PAC is valid (for simplicity of explanation, we can say that the DC will calculate a &ldquo;signature&rdquo; on the PAC content and if this output matches the existing signature, then the PAC will be considered valid) and will respond with a code indicating if it is correct; this packet representing the response has no specific name, it is simply called &ldquo;<a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-apds/b27be921-39b3-4dff-af4a-b7b74deb33b5">PAC RESPONSE</a>&rdquo;.</p>
  <span id=37>
<ol start="8">
<li>
<h3 id="optional-krb_"><strong>(Optional) KRB_AP_REP</strong></h3>
</li>
</ol>
<p>Finally, optionally, if the Client explicitly requests it, even the service itself (and NOT the related service account), so the AP, must authenticate itself performing a so-called &ldquo;mutual authentication&rdquo;; to do this, instead of contacting the AD, the AP responds directly to the Client by sending a <a href="https://datatracker.ietf.org/doc/html/rfc4120#section-5.5.2">KRB_AP_REP</a> (as a response to the previous KRB_AP_REQ) <a href="https://datatracker.ietf.org/doc/html/rfc4120#section-5.5.2">containing a TIMESTAMP encrypted</a> with the &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#19">Service Session Key</a>&rdquo;; if the Client correctly decrypts the TIMESTAMP with the &ldquo;Service Session Key&rdquo; it possesses (the Client has the legitimate &ldquo;Service Session Key&rdquo; because it received it from the DC in the <a href="/posts/not_so_brief_overview_about_kerberos/#19">KRB_TGS_REP</a>), then it is demonstrated that the AP, having the correct &ldquo;Service Session Key&rdquo;, is legitimate (this is because the AP, to have this legitimate &ldquo;Service Session Key&rdquo;, would have had to extract the data from the TGS received from the Client - KRB_AP_REQ - which was encrypted with the &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#29">Service Owner Hash</a>&rdquo;, information that only the legitimate AP should know); in other words, <a href="https://www.educative.io/blog/kerberos-in-5-minutes">in this way the Client is sure it is connecting to the original service</a> and not to another service of a potential attacker pretending to be the original service.</p>
<h2 id="privilege-attribute-certificate-pac"><strong>Privilege Attribute Certificate (PAC)</strong></h2>
<h3 id="what"><strong>What&rsquo;s a Privilege Attribute Certificate (PAC)?</strong></h3>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#18">As already mentioned</a>, the <a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/166d8064-c863-41e1-9c23-edaaa5f36962">Privilege Attribute Certificate (PAC)</a> is a data structure that uses the Kerberos protocol to share with the other actors involved in the authentication, the security information related to the domain account attempting the login, including: Username, ID, Group Membership, and in general all security information.</p>
<p>The PAC is particularly important as it is used during the AUTHORIZATION phase (I want to remind that it is not managed by the Kerberos protocol) respectively either by the Client in an <a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---interactive-login">Interactive Logon</a> or by the AP / Remote Service in a <a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-flow---network-logon">Network Logon to</a> understand if the domain account can access the service or not.</p>
<p>The PAC is contained inside the both types of Kerberos Tickets TGT &amp; TGS (in the &ldquo;authorization-data&rdquo; field), consequently the PAC is indirectly encrypted with the &ldquo;krbtgt&rdquo; account hash in the first case (TGT Ticket) or indirectly encrypted with the service account hash against which the authentication is performed in the second case (TGS Ticket).</p>
<p>Below there is an image that shows the content of a PAC within a TGS Ticket:</p>

    <img src="/not_so_brief_overview_about_kerberos/PAC.png"  class="center"  style="border-radius: 8px;"  />


<p>A traditional account performing Kerberos authentication, NOT knowing the hash to decrypt the TGT Ticket or the hash to decrypt the TGS Ticket, it means that the PAC could not be readable by a traditional user.</p>
<p><span id=11>Furthemore, i want to highlight that the PAC entity itself is issued by the DC in a &ldquo;signed&rdquo; way (not encrypted), meaning that inside it there will be several fields containing the signatures (checksums) calculated on the PAC content with a specific &ldquo;key&rdquo;; these signatures contained inside the PAC can potentially be used to verify the integrity of the PAC it self, below we see <a href="https://trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you">briefly</a>(<a href="https://www.youtube.com/watch?t=871&amp;v=Jaa2LmZaNeU&amp;feature=youtu.be&amp;themeRefresh=1">1</a>) what types of signatures it possesses:</p>
<p><strong>Ticket TGS</strong>:</p>
<ul>
<li>
<p><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/a194aa34-81bd-46a0-a931-2e05b87d1098">Server Signature</a></strong>: &ldquo;Server Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) calculated by signing the PAC content with the secrets of the service account against which authentication is attempted.</p>
</li>
<li>
<p><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3122bf00-ea87-4c3f-92a0-91c0a99f5eec">KDC Signature</a></strong>: &ldquo;KDC Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) created by signing the PAC content with the secret of the &ldquo;<a href="https://www.tarlogic.com/cybersecurity-glossary/krbtgt/">krbtgt</a>&rdquo; account (default service account of the KDC).</p>
</li>
</ul>
<blockquote>
<p>This signature is the one that could be checked inside a TGS Ticket to prevent a Silver Ticket BUT this is <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#pac">NOT</a> done.</p></blockquote>
<p><span id=15> <strong>Ticket TGT</strong>:</p>
<ul>
<li><strong><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-pac/3122bf00-ea87-4c3f-92a0-91c0a99f5eec">KDC Signature</a></strong>: &ldquo;KDC Signature&rdquo; is a field contained in the PAC that holds a string representing the signature (also called checksum) created by signing the PAC content with the secret of the &ldquo;<a href="https://www.tarlogic.com/cybersecurity-glossary/krbtgt/">krbtgt</a>&rdquo; account (default service account of the KDC).</li>
</ul>
<p>In reality the TGT Ticket also has a field dedicated to the &ldquo;Server Signature&rdquo; but having no meaning, since it is the TGS Ticket that is used to authenticate to services and not the TGT Ticket, a &ldquo;symbolic&rdquo; value will be present there which will have no relevance.</p>
<h2 id="kerberos-keys"><strong>Kerberos Keys</strong></h2>
<h3 id="what-1"><strong>What&rsquo;s a Kerberos Key?</strong></h3>
<p>As already seen, the Kerberos protocol allows the user to request a TGT Ticket from the Domain Controller by sending a KRB_AS_REQ encrypting the &ldquo;Timestamp&rdquo; field with the NT Hash of the account performing the authentication, if it is correct everything proceeds properly, that said, in reality, the Kerberos protocol also more generically accepts the entity called &ldquo;Kerberos Keys&rdquo;.</p>
<p>When a domain account is created, the Domain Controller takes the corresponding plaintext password as input and applies different hashing algorithms to it, the outputs of these algorithms are hash values called Kerberos Keys:</p>
<ul>
<li>
<p><strong>AES 256 Key</strong>: &ldquo;AES 256 Key&rdquo; is the output of the plain-text password using the &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">AES256_HMAC_SHA1</a>&rdquo; algorithm.</p>
<p>This &ldquo;AES 256 Key&rdquo; is the Kerberos Key most commonly used by the Kerberos protocol, consequently an attacker using this Key instead of others will be able to bypass detection tools more easily.</p>
</li>
<li>
<p><strong>AES 128 Key</strong>: &ldquo;AES 128 Key&rdquo; is the output of the plain-text password using the &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">AES128_HMAC_SHA1</a>&rdquo; algorithm.</p>
</li>
<li>
<p><strong>DES Key (DES_CBC_MD5)</strong>: &ldquo;DES Key&rdquo; is the output of the plain-text password using the &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">DES_CBC_MD5</a>&rdquo; algorithm.</p>
</li>
<li>
<p><strong>RC4 Key</strong>: &ldquo;RC4 Key&rdquo; is the output of the plain-text password using the now deprecated &ldquo;<a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/network-security-configure-encryption-types-allowed-for-kerberos">RC4_HMAC_MD5</a>&rdquo; algorithm.</p>
<p>This &ldquo;RC4 Key&rdquo; is nothing more than the NT Hash of the domain account password, consequently, being synonyms, it means that the term &ldquo;NT Hash&rdquo; used during the explanation of the Kerberos protocol is nothing more than the &ldquo;RC4 Key&rdquo;.</p>
</li>
</ul>
<p>An attacker is able to retrieve the Kerberos Keys for example by dumping the &ldquo;<a href="https://www.semperis.com/blog/ntds-dit-extraction-explained/">NTDS.dit</a>&rdquo; file from the Domain Controller, below there is an example using the <a href="https://github.com/fortra/impacket/blob/master/examples/secretsdump.py">Secretsdump</a> utility:</p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_key_1.png"  class="center"  style="border-radius: 8px;"  />


<p>In the section indicated above, the &ldquo;RC4 Keys&rdquo; are NOT present because as the tool for semplicity places them in the section dedicated to the NT Hash of the domain accounts.</p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_key_2.png"  class="center"  style="border-radius: 8px;"  />


<p>If an attacker manages to obtain a Kerberos Key of a victim account, they would be able to impersonate it in a Kerberos authentication using an attack called &ldquo;Pass-The-Key&rdquo;.</p>
<h2 id="service-principal-name-spn"><strong>Service Principal Name (SPN)</strong></h2>
<h3 id="what-2"><strong>What&rsquo;s a Service Principal Name (SPN)?</strong></h3>
<p>A &ldquo;<a href="https://en.wikipedia.org/wiki/Service_account">Service Account</a>&rdquo; is nothing more than an account created and used for the start &amp; running of a specific service, furthermore, if this service needs to interact with other services it can do it using its own &ldquo;Service Account&rdquo;.</p>
<p>In a classic scenario when the local or domain user &ldquo;BOB&rdquo; starts the software &ldquo;Notepad&rdquo; application, the operating system runs &ldquo;Notepad&rdquo; using the account &ldquo;BOB&rdquo;, when a Service Account is used, instead, the OS will start the service (for example MSSQL) using that specific Service Account, this will mean that viewing the running processes though Task Manager it will be possible to see that the service &ldquo;Microsoft SQL&rdquo; is running with the related &ldquo;Service Account&rdquo;.</p>
<p>One type of &ldquo;Service Account&rdquo; are the &ldquo;<a href="https://learn.microsoft.com/en-us/windows/win32/services/service-user-accounts">Standard Service Account</a>&rdquo;, so &ldquo;Service Accounts&rdquo; that do NOT have passwords and they are used by Windows OS to start specific services usually system-related, the most common example is the &ldquo;<a href="https://learn.microsoft.com/it-it/windows/win32/services/networkservice-account?redirectedfrom=MSDN">NetworkService Account</a>&rdquo; which is usually used to start the IIS or MSSQL Server service.</p>
<p><span id=30>A <a href="https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names">Service Principal Name (SPN)</a> is a unique identifier of a service instance, SPNs are used by Kerberos authentication to associate the service instance (the start &amp; running of the service, for example Microsoft SQL) with a &ldquo;Logon Account&rdquo; (which it will become Service Account); in other words, (generically speaking) an SPN can be considered as a generic object that represents the association between a service and a domain account, that said, technically, <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">it is an attribute of the &ldquo;Users&rdquo; object</a>.</p>
<p><span id=31>&ldquo;Standard Service Accounts&rdquo; by definition are NOT &ldquo;Logon Accounts&rdquo; since they are used exclusively by the operating system and do NOT have passwords.</p>
<p>This essentially means that through an SPN it is possible to map the start &amp; running of a service on a server to a domain account rather than associating it with a &ldquo;Standard Service Account&rdquo; such as the NetworkService Account.</p>
<p>Each service (hosted on a server joined into a domain) that wants a domain user to authenticate to it using the Kerberos protocol (Kerberos SSO) must necessarily have an SPN configured <a href="/posts/not_so_brief_overview_about_kerberos/#16">so that the potential &ldquo;Client&rdquo; (so the actor involved in Kerberos Authentication) can uniquely identify the service within the network</a>; if no SPN is set for a service, then the Client has NO way to locate the service and consequently the Kerberos authentication is NOT possible.</p>
<p>An SPN (so an attribute of the &ldquo;user&rdquo; object) is (usually, it&rsquo;s not mandatory) built using the name of the &ldquo;service class&rdquo; followed by the hostname that starts the service; finally, optionally, it can also include the port and an arbitrary name to associate:</p>
<p><span id="target-text2">
    <img src="/not_so_brief_overview_about_kerberos/spn1.png"  class="center"  style="border-radius: 8px;"  />

</p>
<p>For example: A SPN named &ldquo;DNS/dc01.capsule.corp&rdquo; rappresent a DNS Service hosted on the DC01.capsule.corp associated with a domain user like &ldquo;capsule.corp\arbitrary_dnsuser&rdquo;.</p>
<p>Microsoft has documented a (non-exhaustive) list of the so-called &ldquo;service_class,&rdquo; that is, standard names used to indicate certain types of services; as you can see, the most common are <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">CIFS, DNS, SPOOLER and WWW</a>.</p>
<h3 id="relationship-between-a-spn--computer-account"><strong>Relationship Between a SPN &amp; Computer Account</strong></h3>
<p>In a domain scenario, each &ldquo;person&rdquo; within the organization will have its own domain user account (so a &ldquo;Users&rdquo; object); that said, every computer joined to the domain will also have its own associated domain account, called a &ldquo;Computer Account&rdquo; or &ldquo;Machine Account&rdquo; (<a href="https://itfreetraining.com/lesson/computer-accounts/">1</a>, <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts">2</a>) which will be used by the Client itself (or more precisely by the SYSTEM account of the Client) for activities where it needs to interact with other entity joined within the domain, for example checking if it is necessary to update the &ldquo;Group Policies&rdquo; (Client -&gt; Domain Controller), <a href="/posts/not_so_brief_overview_about_kerberos/#4">verifying the permissions of a domain account authenticated to the computer with Kerberos and so on</a>.</p>
<p>The difference between a &ldquo;User&rdquo; and a &ldquo;Computer Account&rdquo; is that even though both are domain user that exists and are registered on the DC, the first is an object of type &ldquo;<a href="https://www.windows-active-directory.com/active-directory-user-objects-management.html">User</a>,&rdquo; while the second, that is, the &ldquo;Computer Account,&rdquo; is instead <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts">a subclass of the &ldquo;User&rdquo; class</a> (so we can say it&rsquo;s a user) BUT it is stored within a &ldquo;Computer&rdquo; object.</p>
<p>The following command queries the DC and requests to print on screen all the domain accounts that exists in the AD; as you can see, in addition to the Administrator account, there are: the nominal account (tstark, fcastle, pparker), the service account (SQLService) and 3 other accounts indicated with a $ at the end of the syntax, those are the &ldquo;Computer Accounts&rdquo;; all &ldquo;Computer Accounts&rdquo; (or &ldquo;Machine Accounts&rdquo;) have as their name the associated hostname and end with the $ sign.</p>

    <img src="/not_so_brief_overview_about_kerberos/spn2.png"  class="center"  style="border-radius: 8px;"  />


<p>Consequently, &ldquo;HYDRA-DC$&rdquo; is the &ldquo;Computer Account&rdquo; of the Domain Controller HYDRA-DC, &ldquo;THEPUNISHER$&rdquo; is the &ldquo;Computer Account&rdquo; of the Client THEPUNISHER, and finally &ldquo;SPIDERMAN$&rdquo; is the &ldquo;Computer Account&rdquo; of the Client SPIDERMAN.</p>
<p><span id=34>A &ldquo;Computer Account&rdquo; (Machine Account), unlike a traditional domain user, is automatically generated by the DC when the computer is joined to the domain; specifically, the computer itself randomly (<a href="https://zer1t0.gitlab.io/posts/attacking_ad/#kerberoast">120 characters</a>) creates the password (and then shares it with the DC) and by default it will use the machine’s hostname followed by a $ for the creation of the name; that said, the password of the domain account &ldquo;Computer Account&rdquo; is instead changed <a href="https://adsecurity.org/?p=280">by default</a> (this timing is configurable - <a href="https://techcommunity.microsoft.com/blog/askds/machine-account-password-process/396026">1</a>, <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#lsa-secrets">2</a>) every 30 days.</p>
<p>In addition to the existence of SPNs that allow associating a domain user (becoming a Service Account in this scenario) with a specific service, so by setting a specific &ldquo;Service Class&rdquo; such as CIFS or others, there is also a SPNs of type &ldquo;HOST&rdquo;.</p>
<p>Technically, <a href="/posts/not_so_brief_overview_about_kerberos/#30">as previously told</a>, an SPN was created with the purpose of associating a service with a Service Account (domain user), a SPN of type HOST is the exception to this rule since the keyword &ldquo;HOST&rdquo; is NOT a service but directly represents the whole &ldquo;computer&rdquo; object itself, in order to associate a whole &ldquo;Computer&rdquo; object with a Service Account via SPN, in reality a trick is used, essentially the keyword HOST in order to represent the whole machine but having to necessarily specify a service, the &ldquo;HOST&rdquo; Service Class is an ALIAS (<a href="https://en.hackndo.com/service-principal-name-spn/#edge-case---host">1</a>, <a href="https://learn.microsoft.com/en-us/windows/win32/adschema/a-spnmappings">2</a>, <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">3</a>) that groups together all the possible <a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">Service Class</a> of an SPN such as CIFS, WWW, DNS etc, subsequently it was defined that the Service Account that can be associated with the &ldquo;Computer&rdquo; object (which indirectly holds the Host SPN) via SPN is its corresponding &ldquo;Computer Account&rdquo;, in other words, for example: The SPN &ldquo;HOST\Workstation1&rdquo; links the Computer object &ldquo;Workstation1&rdquo; to the Service Account &ldquo;Workstation1$&rdquo; (which is a Computer Account).</p>
<blockquote>
<p>When a machine is joined to the domain, the corresponding AD Object of type &ldquo;computers&rdquo; is created within the domain, when this happens the Domain Controller automatically creates 2 SPNs to attach to it that follow the following syntax: &ldquo;HOST/&lt;HOSTNAME&gt;&rdquo; &amp; &ldquo;HOST/&lt;HOSTNAME&gt;.&lt;DOMAIN&gt;&rdquo;</p></blockquote>
<p><span id=17>Finally, it should be specified that if a service is run on a computer with a &ldquo;Standard Service Account&rdquo; (for example Local System / NetworkService Account), such as by default the CIFS / LDAP services, if these services need to use the Kerberos protocol (for example they accept a Kerberos domain authentication) the computer will use the &ldquo;Computer Account&rdquo; of the machine that host these services as their Service Account (in this scenario the &ldquo;secrets&rdquo; of the Computer Account will be used to encrypt the TGS Ticket); this happens because the &ldquo;Standard Service Account&rdquo; (ex Local System / NetworkService Account) <a href="/posts/not_so_brief_overview_about_kerberos/#31">exists only in a local context</a>.</p>
<blockquote>
<p>The Service Class &ldquo;HOST&rdquo; also has another utility, since it is assigned by default to a newly created &ldquo;Computer&rdquo; object &amp; it&rsquo;s an alias of ALL &ldquo;Service Classes&rdquo;, it natively configure the domain environment to allow a Client to perform a Kerberos Authentication against commonly used services (e.g: CIFS for SMB authentication, HTTP for WinRM authentication) sparing the Sysadmin the tedious task of manually assigning these SPNs to each machine when it&rsquo;s needed.</p></blockquote>
<h2 id="inspect-the-kerberos-yourself"><strong>Inspect the Kerberos yourself!</strong></h2>
<p>Now that the theory has been explained i recommend moving on to practice!</p>
<p><span id=35>For educational purposes i recommend creating your own personal lab, there are several resources online that detail <a href="https://www.youtube.com/watch?v=xftEuVQ7kY0">how to do this</a>, once this has been done, it will be possible to use WireShark to analyze the traffic started from a Kerberos authentication, to see the whole process we can for example run the command &ldquo;klist purge&rdquo; (which removes all the Cached Kerberos Tickets) on a domain joined Windows machine and perform a Network Logon authentication to another machine within the network, for example via SMB, if you have do this you will see all the Kerberso traffic generated.</p>

    <img src="/not_so_brief_overview_about_kerberos/kerberos_wholeflow.png"  class="center"  style="border-radius: 8px;"  />


<p>As you can see with the following traffic has been generated:</p>
<ol>
<li>KRB_AS_REQ</li>
</ol>
<p>The reason why the 2 &ldquo;KRB_AS_REQ&rdquo; packets were sent <a href="/posts/not_so_brief_overview_about_kerberos/#32">has been previously analyzed.</a></p>
<ol start="2">
<li>KRB_AS_REP</li>
<li>KRB_TGS_REQ</li>
<li>KRB_TGS_REP</li>
</ol>
<p>In this scenario, only &ldquo;<a href="/posts/not_so_brief_overview_about_kerberos/#33">Mutual Authentication</a>&rdquo; is enabled:</p>
<ol start="5">
<li>KRB_AP_REQ: The Kerberos packet &ldquo;KRB_AP_REQ&rdquo; is encapsulated within the packet related to the protocol used by the service hosted by the AP, in this case it&rsquo;s SMB.</li>
</ol>
<ul>
<li>KRB_AP_REP: Since &ldquo;Mutual Authentication&rdquo; is enabled, the AP will respond to the Client with a KRB_AP_REP, always embedding it in this example inside the SMB protocol.</li>
</ul>
<h3 id="how-to-decrypt-kerberos-traffic"><strong>How to decrypt Kerberos traffic</strong></h3>
<p>As previously analyzed, some portions of the Kerberos packets will be encrypted with the krbtgt account secrets (TGT Ticket) or with the Service Account secrets related to the service hosted by the AP (TGS Ticket), to be able to analyze everything in plain-text it&rsquo;s necessary to properly configure Wireshark, specifically it is possible to provide Wireshark with a &ldquo;<a href="https://web.mit.edu/kerberos/krb5-devel/doc/basic/keytab_def.html">keytab</a>&rdquo; file containing ALL the secrets (NT Hash &amp; <a href="/posts/not_so_brief_overview_about_kerberos/#kerberos-keys">Kerberos Key</a>) related to the entities involved in Kerberos authentication, in this way Wireshark will be able to decrypt the part.</p>
<blockquote>
<p><a href="/posts/not_so_brief_overview_about_kerberos/#34">As already explained</a>, since by default the DC changes the password of ALL Computer Accounts every 30 days, if this behavior is not disabled / modified, the operation will need to be repeated periodically.</p></blockquote>
<p>To do this, one can perform a DCSync on the Domain Controller and retrieve the NT Hashes, AES-256 Kerberos Key, and AES-128 Kerberos Key of each involved &ldquo;Principal&rdquo; (Domain Users &amp; Computer Accounts &amp; krbtgt user), then insert these values into the dedicated section in the &ldquo;<a href="https://github.com/dirkjanm/forest-trust-tools/blob/master/keytab.py">keytab.py</a>&rdquo; script and finally execute the script to generate the &ldquo;keytab.kt&rdquo; file:</p>
<ul>
<li>
<p>Dump the &ldquo;secrets&rdquo; (perform a DCSync).</p>

      <img src="/not_so_brief_overview_about_kerberos/dcsync.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
<li>
<p>Populate the &ldquo;<a href="https://github.com/dirkjanm/forest-trust-tools/blob/master/keytab.py">keytab.py</a>&rdquo; script.</p>

      <img src="/not_so_brief_overview_about_kerberos/keytab1.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
<li>
<p>Execute the &ldquo;keytab.py&rdquo; script to generate the &ldquo;keytab.kt&rdquo; file.</p>

      <img src="/not_so_brief_overview_about_kerberos/keytab2.png"  class="center"  style="border-radius: 8px;"  />
  

</li>
</ul>
<p>Once this is done, go to Wireshark and navigate to &ldquo;Edit -&gt; Preferences -&gt; Protocols -&gt; KRB5&rdquo;, select the file and check the box &ldquo;Try to decrypt Kerberos blob&rdquo;.</p>

    <img src="/not_so_brief_overview_about_kerberos/keytab3.png"  class="center"  style="border-radius: 8px;"  />


<p>Once everything is done, all the encrypted Wireshark traffic that has been correctly decrypted will be highlighted in blue, while if the decryption has failed it will be highlighted in yellow:</p>

    <img src="/not_so_brief_overview_about_kerberos/keytab4.png"  class="center"  style="border-radius: 8px;"  />


<h2 id="outro"><strong>Outro</strong></h2>
<p>The Kerberos protocol is a beast to understand and we have only scratched its surface, with this article i hope to have clarified its basic behavior, if you notice any inaccuracies or want to ask me something, do not hesitate to write to me!</p>
<h2 id="references"><strong>References</strong></h2>
<ul>
<li><a href="https://stealthbits.com/blog/what-is-kerberos/">https://stealthbits.com/blog/what-is-kerberos/</a></li>
<li><a href="https://www.tarlogic.com/en/blog/how-kerberos-works/">https://www.tarlogic.com/en/blog/how-kerberos-works/</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-accounts#krbtgt-account">https://docs.microsoft.com/en-us/windows/security/identity-protection/access-control/active-directory-accounts#krbtgt-account</a></li>
<li><a href="https://www.devadmin.it/2020/07/27/account-krbtgt-e-best-practices-di-sicurezza/">https://www.devadmin.it/2020/07/27/account-krbtgt-e-best-practices-di-sicurezza/</a></li>
<li><a href="https://www.educative.io/blog/kerberos-in-5-minutes">https://www.educative.io/blog/kerberos-in-5-minutes</a></li>
<li><a href="https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf">https://redsiege.com/wp-content/uploads/2020/09/SIEGECAST-KERBEROS-AND-ATTACKS-101.pdf</a></li>
<li><a href="https://www.crowdstrike.com/cybersecurity-101/ntlm-windows-new-technology-lan-manager/">https://www.crowdstrike.com/cybersecurity-101/ntlm-windows-new-technology-lan-manager/</a></li>
<li><a href="https://en.hackndo.com/kerberos/">https://en.hackndo.com/kerberos/</a></li>
<li><a href="https://learn.microsoft.com/en-us/archive/blogs/openspecification/">https://learn.microsoft.com/en-us/archive/blogs/openspecification/</a></li>
<li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13">https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-kile/b4af186e-b2ff-43f9-b18e-eedb366abf13</a></li>
<li><a href="https://syfuhs.net/what-happens-when-you-type-your-password-into-windows">https://syfuhs.net/what-happens-when-you-type-your-password-into-windows</a></li>
<li><a href="https://swarm.ptsecurity.com/kerberoasting-without-spns/">https://swarm.ptsecurity.com/kerberoasting-without-spns/</a></li>
<li><a href="https://labs.lares.com/fear-kerberos-pt1/#preauth">https://labs.lares.com/fear-kerberos-pt1/#preauth</a></li>
<li>https//www.chudamax.com/posts/kerberos-102-overview/</li>
<li><a href="https://en.hackndo.com/kerberos-silver-golden-tickets/#pac">https://en.hackndo.com/kerberos-silver-golden-tickets/#pac</a> <a href="https://zer1t0.gitlab.io/posts/attacking_ad/#pac">https://zer1t0.gitlab.io/posts/attacking_ad/#pac</a></li>
<li><a href="https://trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you">https://trustedsec.com/blog/red-vs-blue-kerberos-ticket-times-checksums-and-you</a></li>
<li><a href="https://labs.lares.com/author/raul/">https://labs.lares.com/author/raul/</a></li>
<li><a href="https://zer1t0.gitlab.io/posts/attacking_ad/#user-kerberos-keys">https://zer1t0.gitlab.io/posts/attacking_ad/#user-kerberos-keys</a></li>
<li><a href="https://www.thehacker.recipes/ad/movement/kerberos/ptk">https://www.thehacker.recipes/ad/movement/kerberos/ptk</a></li>
<li><a href="https://en.wikipedia.org/wiki/Service_account">https://en.wikipedia.org/wiki/Service_account</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names">https://learn.microsoft.com/en-us/windows/win32/ad/service-principal-names</a></li>
<li><a href="https://malicious.link/posts/2016/kerberoast-pt1/">https://malicious.link/posts/2016/kerberoast-pt1/</a></li>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815%28v=ws.10%29#service-principal-names">https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc772815(v=ws.10)#service-principal-names</a></li>
<li><a href="https://en.hackndo.com/service-principal-name-spn/#edge-case---host">https://en.hackndo.com/service-principal-name-spn/#edge-case---host</a></li>
<li><a href="https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts">https://zer1t0.gitlab.io/posts/attacking_ad/#computer-accounts</a></li>
</ul>
]]></content></item></channel></rss>